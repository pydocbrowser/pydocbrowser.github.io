<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>sqlalchemy.ext.hybrid</title>
    <meta name="generator" content="pydoctor 22.9.1.dev0"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1 maximum-scale=1" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    <div id="banner">    
    <div>
        <a href="/">Home</a>
        &gt; sqlalchemy-2.0.8 <!-- This is a placeholder -->
        
        <!-- (<a href=""&gt;show all versions</a&gt;) -->
    </div>
</div>

    <nav class="navbar navbar-default mainnavbar">
      
  
  <div class="container-fluid">


    <div class="navbar-header">
      
      <div class="navlinks">
        <span class="navbar-brand">
          sqlalchemy <a href="index.html">API Documentation</a>
        </span>

        <a href="moduleIndex.html">
          Modules
        </a>

        <a href="classIndex.html">
          Classes
        </a>

        <a href="nameIndex.html">
          Names
        </a>

        <div id="search-box-container">
          <div class="input-group">
            <input id="search-box" type="search" name="search-query" placeholder="Search..." aria-label="Search" minlength="2" class="form-control" autocomplete="off" />
            
            <span class="input-group-btn">
              <a style="display: none;" class="btn btn-default" id="search-clear-button" title="Clear" onclick="clearSearch()"><img src="fonts/x-circle.svg" alt="Clear" /></a>
              <a class="btn btn-default" id="search-help-button" title="Help" onclick="toggleSearchHelpText()"><img src="fonts/info.svg" alt="Help" /></a>
            </span>
          </div>
        </div>

      </div>

      <div id="search-results-container" style="display: none;">
        
        <div id="search-buttons">
          <span class="label label-default" id="search-docstrings-button">
          <label class="checkbox-inline">
            <input type="checkbox" id="toggle-search-in-docstrings-checkbox" value="false" onclick="toggleSearchInDocstrings()">
              search in docstrings
            </input>
          </label>
          </span>
          
        </div>
        
        <noscript>
            <h1>Cannot search: JavaScript is not supported/enabled in your browser.</h1>
        </noscript>

        <div class="hint" id="search-help-box">
          <p class="rst-last">
      
            Search bar offers the following options:
            <ul>   
                <li>
                  <strong>Term presence.</strong> The below example searches for documents that 
                    must contain “foo”, might contain “bar” and must not contain “baz”: <code>+foo bar -baz</code>
                </li> 

                <li>
                  <strong>Wildcards.</strong> The below example searches for documents with words beginning with “foo”: <code>foo*</code>
                </li> 

                <li>
                  <strong>Search in specific fields.</strong> The following search matches all objects 
                  in "twisted.mail" that matches “search”: <code>+qname:twisted.mail.* +search</code>

                  <p>
                    Possible fields: 'name', 'qname' (fully qualified name), 'docstring', and 'kind'.
                    Last two fields are only applicable if "search in docstrings" is enabled.
                  </p>
                </li>

                <li>
                  <strong>Fuzzy matches.</strong> The following search matches all documents 
                  that have a word within 1 edit distance of “foo”: <code>foo~1</code>
                </li>
            </ul>

          </p>
        </div>

        <div id="search-status"> </div>

        <div class="warning" id="search-warn-box" style="display: none;">
          <p class="rst-last"><span id="search-warn"></span></p>
        </div>

        <table id="search-results">
          <!-- Filled dynamically by JS -->
        </table>
        
        <div style="margin-top: 8px;">
          <p>Results provided by <a href="https://lunrjs.com">Lunr.js</a></p>
        </div>
      </div>

    </div>


  </div>
</nav>
    
    <div class="container-fluid">

      <!-- Side navigation -->
      <div class="sidebarcontainer" style="display: none;">
        
        <div class="sidebar"><nav class="sidebar">
  

  <div>

      <div class="thingTitle">
        <span>Module</span>
        <code class="thisobject"><a href="sqlalchemy.ext.hybrid.html" class="internal-link" title="This module">hybrid</a></code> 
      </div>
      
      <div>
        

        
         

        <div class="childrenKindTitle">Classes</div>
        <ul>
    
    <li class="">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.hybrid.Comparator.html" class="internal-link" title="sqlalchemy.ext.hybrid.Comparator"><wbr></wbr>Comparator</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.hybrid.ExprComparator.html" class="internal-link" title="sqlalchemy.ext.hybrid.ExprComparator"><wbr></wbr>Expr<wbr></wbr>Comparator</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.hybrid.hybrid_method.html" class="internal-link" title="sqlalchemy.ext.hybrid.hybrid_method">hybrid<wbr></wbr>_method</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.hybrid.hybrid_property.html" class="internal-link" title="sqlalchemy.ext.hybrid.hybrid_property">hybrid<wbr></wbr>_property</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.hybrid.HybridExtensionType.html" class="internal-link" title="sqlalchemy.ext.hybrid.HybridExtensionType"><wbr></wbr>Hybrid<wbr></wbr>Extension<wbr></wbr>Type</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.hybrid._HybridClassLevelAccessor.html" class="internal-link" title="sqlalchemy.ext.hybrid._HybridClassLevelAccessor">_<wbr></wbr>Hybrid<wbr></wbr>Class<wbr></wbr>Level<wbr></wbr>Accessor</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.hybrid._HybridComparatorCallableType.html" class="internal-link" title="sqlalchemy.ext.hybrid._HybridComparatorCallableType">_<wbr></wbr>Hybrid<wbr></wbr>Comparator<wbr></wbr>Callable<wbr></wbr>Type</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.hybrid._HybridDeleterType.html" class="internal-link" title="sqlalchemy.ext.hybrid._HybridDeleterType">_<wbr></wbr>Hybrid<wbr></wbr>Deleter<wbr></wbr>Type</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.hybrid._HybridExprCallableType.html" class="internal-link" title="sqlalchemy.ext.hybrid._HybridExprCallableType">_<wbr></wbr>Hybrid<wbr></wbr>Expr<wbr></wbr>Callable<wbr></wbr>Type</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.hybrid._HybridGetterType.html" class="internal-link" title="sqlalchemy.ext.hybrid._HybridGetterType">_<wbr></wbr>Hybrid<wbr></wbr>Getter<wbr></wbr>Type</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.hybrid._HybridSetterType.html" class="internal-link" title="sqlalchemy.ext.hybrid._HybridSetterType">_<wbr></wbr>Hybrid<wbr></wbr>Setter<wbr></wbr>Type</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.hybrid._HybridUpdaterType.html" class="internal-link" title="sqlalchemy.ext.hybrid._HybridUpdaterType">_<wbr></wbr>Hybrid<wbr></wbr>Updater<wbr></wbr>Type</a></code>
            </div>
        

    </li>
</ul>

        <div class="childrenKindTitle">Functions</div>
        <ul>
    
    <li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_unwrap_classmethod" class="internal-link" title="sqlalchemy.ext.hybrid._unwrap_classmethod">_unwrap<wbr></wbr>_classmethod</a></code>
            </div>
        

    </li>
</ul> 

        
         

        <div class="childrenKindTitle">Variables</div>
        <ul>
    
    <li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_P" class="internal-link" title="sqlalchemy.ext.hybrid._P">_P</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_R" class="internal-link" title="sqlalchemy.ext.hybrid._R">_R</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_T" class="internal-link" title="sqlalchemy.ext.hybrid._T">_T</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_T_co" class="internal-link" title="sqlalchemy.ext.hybrid._T_co">_<wbr></wbr>T_co</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_T_con" class="internal-link" title="sqlalchemy.ext.hybrid._T_con">_<wbr></wbr>T_con</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_TE" class="internal-link" title="sqlalchemy.ext.hybrid._TE">_TE</a></code>
            </div>
        

    </li>
</ul> 

        
         
        
      </div>
  </div><div>

      <div class="thingTitle">
        <span>Package</span>
        <code><a href="sqlalchemy.ext.html" class="internal-link" title="The parent of this module">ext</a></code> 
      </div>
      
      <div>
        

        <div class="childrenKindTitle">Modules</div>
        <ul>
    
    <li class="">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.asyncio.html" class="internal-link" title="sqlalchemy.ext.asyncio">asyncio</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.declarative.html" class="internal-link" title="sqlalchemy.ext.declarative">declarative</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.mypy.html" class="internal-link" title="sqlalchemy.ext.mypy">mypy</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.associationproxy.html" class="internal-link" title="sqlalchemy.ext.associationproxy">associationproxy</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.automap.html" class="internal-link" title="sqlalchemy.ext.automap">automap</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.baked.html" class="internal-link" title="sqlalchemy.ext.baked">baked</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.compiler.html" class="internal-link" title="sqlalchemy.ext.compiler">compiler</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.horizontal_shard.html" class="internal-link" title="sqlalchemy.ext.horizontal_shard">horizontal<wbr></wbr>_shard</a></code>
            </div>
        

    </li><li class=" thisobject">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.hybrid.html" class="internal-link" title="sqlalchemy.ext.hybrid">hybrid</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.indexable.html" class="internal-link" title="sqlalchemy.ext.indexable">indexable</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.instrumentation.html" class="internal-link" title="sqlalchemy.ext.instrumentation">instrumentation</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.mutable.html" class="internal-link" title="sqlalchemy.ext.mutable">mutable</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.orderinglist.html" class="internal-link" title="sqlalchemy.ext.orderinglist">orderinglist</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="sqlalchemy.ext.serializer.html" class="internal-link" title="sqlalchemy.ext.serializer">serializer</a></code>
            </div>
        

    </li>
</ul> 

        
        

        
         

        
         

        
         

        
         
        
      </div>
  </div>

</nav>
        </div>
        <div id="collapseSideBar">
          <a class="btn btn-link" onclick="toggleSideBarCollapse()" title="Toggle Sidebar Collapse">
          </a>
        </div> 
        <script src="sidebartoggle.js" type="text/javascript"></script>
       
      </div>

      <div id="main" class="">
        

        

        <div class="page-header">
          <h1 class="module"><code><code><a href="index.html" class="internal-link">sqlalchemy</a></code><wbr></wbr>.<code><a href="sqlalchemy.ext.html" class="internal-link" title="sqlalchemy.ext">ext</a></code><wbr></wbr>.<code><a href="sqlalchemy.ext.hybrid.html" class="internal-link" title="sqlalchemy.ext.hybrid">hybrid</a></code></code></h1>
          <div id="showPrivate">
            <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
          </div>
        </div>

        <div class="categoryHeader">
          module documentation
        </div>

        <div class="extrasDocstring">
          <a href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-2.0.8//lib/sqlalchemy/ext/hybrid.py" class="sourceLink">(source)</a>
          <p></p>
        </div>

        <div class="moduleDocstring">
          <div><p class="pre">Define attributes on ORM-mapped classes that have "hybrid" behavior.

"hybrid" means the attribute has distinct behaviors defined at the
class level and at the instance level.

The :mod:`~sqlalchemy.ext.hybrid` extension provides a special form of
method decorator and has minimal dependencies on the rest of SQLAlchemy.
Its basic theory of operation can work with any descriptor-based expression
system.

Consider a mapping ``Interval``, representing integer ``start`` and ``end``
values. We can define higher level functions on mapped classes that produce SQL
expressions at the class level, and Python expression evaluation at the
instance level.  Below, each function decorated with :class:`.hybrid_method` or
:class:`.hybrid_property` may receive ``self`` as an instance of the class, or
may receive the class directly, depending on context::

    from __future__ import annotations

    from sqlalchemy.ext.hybrid import hybrid_method
    from sqlalchemy.ext.hybrid import hybrid_property
    from sqlalchemy.orm import DeclarativeBase
    from sqlalchemy.orm import Mapped
    from sqlalchemy.orm import mapped_column


    class Base(DeclarativeBase):
        pass

    class Interval(Base):
        __tablename__ = 'interval'

        id: Mapped[int] = mapped_column(primary_key=True)
        start: Mapped[int]
        end: Mapped[int]

        def __init__(self, start: int, end: int):
            self.start = start
            self.end = end

        @hybrid_property
        def length(self) -&gt; int:
            return self.end - self.start

        @hybrid_method
        def contains(self, point: int) -&gt; bool:
            return (self.start &lt;= point) &amp; (point &lt;= self.end)

        @hybrid_method
        def intersects(self, other: Interval) -&gt; bool:
            return self.contains(other.start) | self.contains(other.end)


Above, the ``length`` property returns the difference between the
``end`` and ``start`` attributes.  With an instance of ``Interval``,
this subtraction occurs in Python, using normal Python descriptor
mechanics::

    &gt;&gt;&gt; i1 = Interval(5, 10)
    &gt;&gt;&gt; i1.length
    5

When dealing with the ``Interval`` class itself, the :class:`.hybrid_property`
descriptor evaluates the function body given the ``Interval`` class as
the argument, which when evaluated with SQLAlchemy expression mechanics
returns a new SQL expression:

.. sourcecode:: pycon+sql

    &gt;&gt;&gt; from sqlalchemy import select
    &gt;&gt;&gt; print(select(Interval.length))
    {printsql}SELECT interval."end" - interval.start AS length
    FROM interval{stop}


    &gt;&gt;&gt; print(select(Interval).filter(Interval.length &gt; 10))
    {printsql}SELECT interval.id, interval.start, interval."end"
    FROM interval
    WHERE interval."end" - interval.start &gt; :param_1

Filtering methods such as :meth:`.Select.filter_by` are supported
with hybrid attributes as well:

.. sourcecode:: pycon+sql

    &gt;&gt;&gt; print(select(Interval).filter_by(length=5))
    {printsql}SELECT interval.id, interval.start, interval."end"
    FROM interval
    WHERE interval."end" - interval.start = :param_1

The ``Interval`` class example also illustrates two methods,
``contains()`` and ``intersects()``, decorated with
:class:`.hybrid_method`. This decorator applies the same idea to
methods that :class:`.hybrid_property` applies to attributes.   The
methods return boolean values, and take advantage of the Python ``|``
and ``&amp;`` bitwise operators to produce equivalent instance-level and
SQL expression-level boolean behavior:

.. sourcecode:: pycon+sql

    &gt;&gt;&gt; i1.contains(6)
    True
    &gt;&gt;&gt; i1.contains(15)
    False
    &gt;&gt;&gt; i1.intersects(Interval(7, 18))
    True
    &gt;&gt;&gt; i1.intersects(Interval(25, 29))
    False

    &gt;&gt;&gt; print(select(Interval).filter(Interval.contains(15)))
    {printsql}SELECT interval.id, interval.start, interval."end"
    FROM interval
    WHERE interval.start &lt;= :start_1 AND interval."end" &gt; :end_1{stop}

    &gt;&gt;&gt; ia = aliased(Interval)
    &gt;&gt;&gt; print(select(Interval, ia).filter(Interval.intersects(ia)))
    {printsql}SELECT interval.id, interval.start,
    interval."end", interval_1.id AS interval_1_id,
    interval_1.start AS interval_1_start, interval_1."end" AS interval_1_end
    FROM interval, interval AS interval_1
    WHERE interval.start &lt;= interval_1.start
        AND interval."end" &gt; interval_1.start
        OR interval.start &lt;= interval_1."end"
        AND interval."end" &gt; interval_1."end"{stop}

.. _hybrid_distinct_expression:

Defining Expression Behavior Distinct from Attribute Behavior
--------------------------------------------------------------

In the previous section, our usage of the ``&amp;`` and ``|`` bitwise operators
within the ``Interval.contains`` and ``Interval.intersects`` methods was
fortunate, considering our functions operated on two boolean values to return a
new one. In many cases, the construction of an in-Python function and a
SQLAlchemy SQL expression have enough differences that two separate Python
expressions should be defined. The :mod:`~sqlalchemy.ext.hybrid` decorator
defines a **modifier** :meth:`.hybrid_property.expression` for this purpose. As an
example we'll define the radius of the interval, which requires the usage of
the absolute value function::

    from sqlalchemy import ColumnElement
    from sqlalchemy import Float
    from sqlalchemy import func
    from sqlalchemy import type_coerce

    class Interval(Base):
        # ...

        @hybrid_property
        def radius(self) -&gt; float:
            return abs(self.length) / 2

        @radius.inplace.expression
        @classmethod
        def _radius_expression(cls) -&gt; ColumnElement[float]:
            return type_coerce(func.abs(cls.length) / 2, Float)

In the above example, the :class:`.hybrid_property` first assigned to the
name ``Interval.radius`` is amended by a subsequent method called
``Interval._radius_expression``, using the decorator
``@radius.inplace.expression``, which chains together two modifiers
:attr:`.hybrid_property.inplace` and :attr:`.hybrid_property.expression`.
The use of :attr:`.hybrid_property.inplace` indicates that the
:meth:`.hybrid_property.expression` modifier should mutate the
existing hybrid object at ``Interval.radius`` in place, without creating a
new object.   Notes on this modifier and its
rationale are discussed in the next section :ref:`hybrid_pep484_naming`.
The use of ``@classmethod`` is optional, and is strictly to give typing
tools a hint that ``cls`` in this case is expected to be the ``Interval``
class, and not an instance of ``Interval``.

.. note:: :attr:`.hybrid_property.inplace` as well as the use of ``@classmethod``
   for proper typing support are available as of SQLAlchemy 2.0.4, and will
   not work in earlier versions.

With ``Interval.radius`` now including an expression element, the SQL
function ``ABS()`` is returned when accessing ``Interval.radius``
at the class level:

.. sourcecode:: pycon+sql

    &gt;&gt;&gt; from sqlalchemy import select
    &gt;&gt;&gt; print(select(Interval).filter(Interval.radius &gt; 5))
    {printsql}SELECT interval.id, interval.start, interval."end"
    FROM interval
    WHERE abs(interval."end" - interval.start) / :abs_1 &gt; :param_1


.. _hybrid_pep484_naming:

Using ``inplace`` to create pep-484 compliant hybrid properties
---------------------------------------------------------------

In the previous section, a :class:`.hybrid_property` decorator is illustrated
which includes two separate method-level functions being decorated, both
to produce a single object attribute referred towards as ``Interval.radius``.
There are actually several different modifiers we can use for
:class:`.hybrid_property` including :meth:`.hybrid_property.expression`,
:meth:`.hybrid_property.setter` and :meth:`.hybrid_property.update_expression`.

SQLAlchemy's :class:`.hybrid_property` decorator intends that adding on these
methods may be done in the identical manner as Python's built-in
``@property`` decorator, where idiomatic use is to continue to redefine the
attribute repeatedly, using the **same attribute name** each time, as in the
example below that illustrates the use of :meth:`.hybrid_property.setter` and
:meth:`.hybrid_property.expression` for the ``Interval.radius`` descriptor::

    # correct use, however is not accepted by pep-484 tooling

    class Interval(Base):
        # ...

        @hybrid_property
        def radius(self):
            return abs(self.length) / 2

        @radius.setter
        def radius(self, value):
            self.length = value * 2

        @radius.expression
        def radius(cls):
            return type_coerce(func.abs(cls.length) / 2, Float)

Above, there are three ``Interval.radius`` methods, but as each are decorated,
first by the :class:`.hybrid_property` decorator and then by the
``@radius`` name itself, the end effect is that ``Interval.radius`` is
a single attribute with three different functions contained within it.
This style of use is taken from `Python's documented use of @property
&lt;https://docs.python.org/3/library/functions.html#property&gt;`_.
It is important to note that the way both ``@property`` as well as
:class:`.hybrid_property` work, a **copy of the descriptor is made each time**.
That is, each call to ``@radius.expression``, ``@radius.setter`` etc.
make a new object entirely.  This allows the attribute to be re-defined in
subclasses without issue (see :ref:`hybrid_reuse_subclass` later in this
section for how this is used).

However, the above approach is not compatible with typing tools such as
mypy and pyright.  Python's own ``@property`` decorator does not have this
limitation only because
`these tools hardcode the behavior of @property
&lt;https://github.com/python/typing/discussions/1102&gt;`_, meaning this syntax
is not available to SQLAlchemy under :pep:`484` compliance.

In order to produce a reasonable syntax while remaining typing compliant,
the :attr:`.hybrid_property.inplace` decorator allows the same
decorator to be re-used with different method names, while still producing
a single decorator under one name::

    # correct use which is also accepted by pep-484 tooling

    class Interval(Base):
        # ...

        @hybrid_property
        def radius(self) -&gt; float:
            return abs(self.length) / 2

        @radius.inplace.setter
        def _radius_setter(self, value: float) -&gt; None:
            # for example only
            self.length = value * 2

        @radius.inplace.expression
        @classmethod
        def _radius_expression(cls) -&gt; ColumnElement[float]:
            return type_coerce(func.abs(cls.length) / 2, Float)

Using :attr:`.hybrid_property.inplace` further qualifies the use of the
decorator that a new copy should not be made, thereby maintaining the
``Interval.radius`` name while allowing additional methods
``Interval._radius_setter`` and ``Interval._radius_expression`` to be
differently named.


.. versionadded:: 2.0.4 Added :attr:`.hybrid_property.inplace` to allow
   less verbose construction of composite :class:`.hybrid_property` objects
   while not having to use repeated method names.   Additionally allowed the
   use of ``@classmethod`` within :attr:`.hybrid_property.expression`,
   :attr:`.hybrid_property.update_expression`, and
   :attr:`.hybrid_property.comparator` to allow typing tools to identify
   ``cls`` as a class and not an instance in the method signature.


Defining Setters
----------------

The :meth:`.hybrid_property.setter` modifier allows the construction of a
custom setter method, that can modify values on the object::

    class Interval(Base):
        # ...

        @hybrid_property
        def length(self) -&gt; int:
            return self.end - self.start

        @length.inplace.setter
        def _length_setter(self, value: int) -&gt; None:
            self.end = self.start + value

The ``length(self, value)`` method is now called upon set::

    &gt;&gt;&gt; i1 = Interval(5, 10)
    &gt;&gt;&gt; i1.length
    5
    &gt;&gt;&gt; i1.length = 12
    &gt;&gt;&gt; i1.end
    17

.. _hybrid_bulk_update:

Allowing Bulk ORM Update
------------------------

A hybrid can define a custom "UPDATE" handler for when using
ORM-enabled updates, allowing the hybrid to be used in the
SET clause of the update.

Normally, when using a hybrid with :func:`_sql.update`, the SQL
expression is used as the column that's the target of the SET.  If our
``Interval`` class had a hybrid ``start_point`` that linked to
``Interval.start``, this could be substituted directly::

    from sqlalchemy import update
    stmt = update(Interval).values({Interval.start_point: 10})

However, when using a composite hybrid like ``Interval.length``, this
hybrid represents more than one column.   We can set up a handler that will
accommodate a value passed in the VALUES expression which can affect
this, using the :meth:`.hybrid_property.update_expression` decorator.
A handler that works similarly to our setter would be::

    from typing import List, Tuple, Any

    class Interval(Base):
        # ...

        @hybrid_property
        def length(self) -&gt; int:
            return self.end - self.start

        @length.inplace.setter
        def _length_setter(self, value: int) -&gt; None:
            self.end = self.start + value

        @length.inplace.update_expression
        def _length_update_expression(cls, value: Any) -&gt; List[Tuple[Any, Any]]:
            return [
                (cls.end, cls.start + value)
            ]

Above, if we use ``Interval.length`` in an UPDATE expression, we get
a hybrid SET expression:

.. sourcecode:: pycon+sql


    &gt;&gt;&gt; from sqlalchemy import update
    &gt;&gt;&gt; print(update(Interval).values({Interval.length: 25}))
    {printsql}UPDATE interval SET "end"=(interval.start + :start_1)

This SET expression is accommodated by the ORM automatically.

.. seealso::

    :ref:`orm_expression_update_delete` - includes background on ORM-enabled
    UPDATE statements


Working with Relationships
--------------------------

There's no essential difference when creating hybrids that work with
related objects as opposed to column-based data. The need for distinct
expressions tends to be greater.  The two variants we'll illustrate
are the "join-dependent" hybrid, and the "correlated subquery" hybrid.

Join-Dependent Relationship Hybrid
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Consider the following declarative
mapping which relates a ``User`` to a ``SavingsAccount``::

    from __future__ import annotations

    from decimal import Decimal
    from typing import cast
    from typing import List
    from typing import Optional

    from sqlalchemy import ForeignKey
    from sqlalchemy import Numeric
    from sqlalchemy import String
    from sqlalchemy import SQLColumnExpression
    from sqlalchemy.ext.hybrid import hybrid_property
    from sqlalchemy.orm import DeclarativeBase
    from sqlalchemy.orm import Mapped
    from sqlalchemy.orm import mapped_column
    from sqlalchemy.orm import relationship


    class Base(DeclarativeBase):
        pass


    class SavingsAccount(Base):
        __tablename__ = 'account'
        id: Mapped[int] = mapped_column(primary_key=True)
        user_id: Mapped[int] = mapped_column(ForeignKey('user.id'))
        balance: Mapped[Decimal] = mapped_column(Numeric(15, 5))

        owner: Mapped[User] = relationship(back_populates="accounts")

    class User(Base):
        __tablename__ = 'user'
        id: Mapped[int] = mapped_column(primary_key=True)
        name: Mapped[str] = mapped_column(String(100))

        accounts: Mapped[List[SavingsAccount]] = relationship(
            back_populates="owner", lazy="selectin"
        )

        @hybrid_property
        def balance(self) -&gt; Optional[Decimal]:
            if self.accounts:
                return self.accounts[0].balance
            else:
                return None

        @balance.inplace.setter
        def _balance_setter(self, value: Optional[Decimal]) -&gt; None:
            assert value is not None

            if not self.accounts:
                account = SavingsAccount(owner=self)
            else:
                account = self.accounts[0]
            account.balance = value

        @balance.inplace.expression
        @classmethod
        def _balance_expression(cls) -&gt; SQLColumnExpression[Optional[Decimal]]:
            return cast("SQLColumnExpression[Optional[Decimal]]", SavingsAccount.balance)

The above hybrid property ``balance`` works with the first
``SavingsAccount`` entry in the list of accounts for this user.   The
in-Python getter/setter methods can treat ``accounts`` as a Python
list available on ``self``.

.. tip:: The ``User.balance`` getter in the above example accesses the
   ``self.acccounts`` collection, which will normally be loaded via the
   :func:`.selectinload` loader strategy configured on the ``User.balance``
   :func:`_orm.relationship`. The default loader strategy when not otherwise
   stated on :func:`_orm.relationship` is :func:`.lazyload`, which emits SQL on
   demand. When using asyncio, on-demand loaders such as :func:`.lazyload` are
   not supported, so care should be taken to ensure the ``self.accounts``
   collection is accessible to this hybrid accessor when using asyncio.

At the expression level, it's expected that the ``User`` class will
be used in an appropriate context such that an appropriate join to
``SavingsAccount`` will be present:

.. sourcecode:: pycon+sql

    &gt;&gt;&gt; from sqlalchemy import select
    &gt;&gt;&gt; print(select(User, User.balance).
    ...       join(User.accounts).filter(User.balance &gt; 5000))
    {printsql}SELECT "user".id AS user_id, "user".name AS user_name,
    account.balance AS account_balance
    FROM "user" JOIN account ON "user".id = account.user_id
    WHERE account.balance &gt; :balance_1

Note however, that while the instance level accessors need to worry
about whether ``self.accounts`` is even present, this issue expresses
itself differently at the SQL expression level, where we basically
would use an outer join:

.. sourcecode:: pycon+sql

    &gt;&gt;&gt; from sqlalchemy import select
    &gt;&gt;&gt; from sqlalchemy import or_
    &gt;&gt;&gt; print (select(User, User.balance).outerjoin(User.accounts).
    ...         filter(or_(User.balance &lt; 5000, User.balance == None)))
    {printsql}SELECT "user".id AS user_id, "user".name AS user_name,
    account.balance AS account_balance
    FROM "user" LEFT OUTER JOIN account ON "user".id = account.user_id
    WHERE account.balance &lt;  :balance_1 OR account.balance IS NULL

Correlated Subquery Relationship Hybrid
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We can, of course, forego being dependent on the enclosing query's usage
of joins in favor of the correlated subquery, which can portably be packed
into a single column expression. A correlated subquery is more portable, but
often performs more poorly at the SQL level. Using the same technique
illustrated at :ref:`mapper_column_property_sql_expressions`,
we can adjust our ``SavingsAccount`` example to aggregate the balances for
*all* accounts, and use a correlated subquery for the column expression::

    from __future__ import annotations

    from decimal import Decimal
    from typing import List

    from sqlalchemy import ForeignKey
    from sqlalchemy import func
    from sqlalchemy import Numeric
    from sqlalchemy import select
    from sqlalchemy import SQLColumnExpression
    from sqlalchemy import String
    from sqlalchemy.ext.hybrid import hybrid_property
    from sqlalchemy.orm import DeclarativeBase
    from sqlalchemy.orm import Mapped
    from sqlalchemy.orm import mapped_column
    from sqlalchemy.orm import relationship


    class Base(DeclarativeBase):
        pass


    class SavingsAccount(Base):
        __tablename__ = 'account'
        id: Mapped[int] = mapped_column(primary_key=True)
        user_id: Mapped[int] = mapped_column(ForeignKey('user.id'))
        balance: Mapped[Decimal] = mapped_column(Numeric(15, 5))

        owner: Mapped[User] = relationship(back_populates="accounts")

    class User(Base):
        __tablename__ = 'user'
        id: Mapped[int] = mapped_column(primary_key=True)
        name: Mapped[str] = mapped_column(String(100))

        accounts: Mapped[List[SavingsAccount]] = relationship(
            back_populates="owner", lazy="selectin"
        )

        @hybrid_property
        def balance(self) -&gt; Decimal:
            return sum((acc.balance for acc in self.accounts), start=Decimal("0"))

        @balance.inplace.expression
        @classmethod
        def _balance_expression(cls) -&gt; SQLColumnExpression[Decimal]:
            return (
                select(func.sum(SavingsAccount.balance))
                .where(SavingsAccount.user_id == cls.id)
                .label("total_balance")
            )


The above recipe will give us the ``balance`` column which renders
a correlated SELECT:

.. sourcecode:: pycon+sql

    &gt;&gt;&gt; from sqlalchemy import select
    &gt;&gt;&gt; print(select(User).filter(User.balance &gt; 400))
    {printsql}SELECT "user".id, "user".name
    FROM "user"
    WHERE (
        SELECT sum(account.balance) AS sum_1 FROM account
        WHERE account.user_id = "user".id
    ) &gt; :param_1


.. _hybrid_custom_comparators:

Building Custom Comparators
---------------------------

The hybrid property also includes a helper that allows construction of
custom comparators. A comparator object allows one to customize the
behavior of each SQLAlchemy expression operator individually.  They
are useful when creating custom types that have some highly
idiosyncratic behavior on the SQL side.

.. note::  The :meth:`.hybrid_property.comparator` decorator introduced
   in this section **replaces** the use of the
   :meth:`.hybrid_property.expression` decorator.
   They cannot be used together.

The example class below allows case-insensitive comparisons on the attribute
named ``word_insensitive``::

    from __future__ import annotations

    from typing import Any

    from sqlalchemy import ColumnElement
    from sqlalchemy import func
    from sqlalchemy.ext.hybrid import Comparator
    from sqlalchemy.ext.hybrid import hybrid_property
    from sqlalchemy.orm import DeclarativeBase
    from sqlalchemy.orm import Mapped
    from sqlalchemy.orm import mapped_column

    class Base(DeclarativeBase):
        pass


    class CaseInsensitiveComparator(Comparator[str]):
        def __eq__(self, other: Any) -&gt; ColumnElement[bool]:  # type: ignore[override]  # noqa: E501
            return func.lower(self.__clause_element__()) == func.lower(other)

    class SearchWord(Base):
        __tablename__ = 'searchword'

        id: Mapped[int] = mapped_column(primary_key=True)
        word: Mapped[str]

        @hybrid_property
        def word_insensitive(self) -&gt; str:
            return self.word.lower()

        @word_insensitive.inplace.comparator
        @classmethod
        def _word_insensitive_comparator(cls) -&gt; CaseInsensitiveComparator:
            return CaseInsensitiveComparator(cls.word)

Above, SQL expressions against ``word_insensitive`` will apply the ``LOWER()``
SQL function to both sides:

.. sourcecode:: pycon+sql

    &gt;&gt;&gt; from sqlalchemy import select
    &gt;&gt;&gt; print(select(SearchWord).filter_by(word_insensitive="Trucks"))
    {printsql}SELECT searchword.id, searchword.word
    FROM searchword
    WHERE lower(searchword.word) = lower(:lower_1)


The ``CaseInsensitiveComparator`` above implements part of the
:class:`.ColumnOperators` interface.   A "coercion" operation like
lowercasing can be applied to all comparison operations (i.e. ``eq``,
``lt``, ``gt``, etc.) using :meth:`.Operators.operate`::

    class CaseInsensitiveComparator(Comparator):
        def operate(self, op, other, **kwargs):
            return op(
                func.lower(self.__clause_element__()),
                func.lower(other),
                **kwargs,
            )

.. _hybrid_reuse_subclass:

Reusing Hybrid Properties across Subclasses
-------------------------------------------

A hybrid can be referred to from a superclass, to allow modifying
methods like :meth:`.hybrid_property.getter`, :meth:`.hybrid_property.setter`
to be used to redefine those methods on a subclass.  This is similar to
how the standard Python ``@property`` object works::

    class FirstNameOnly(Base):
        # ...

        first_name: Mapped[str]

        @hybrid_property
        def name(self) -&gt; str:
            return self.first_name

        @name.inplace.setter
        def _name_setter(self, value: str) -&gt; None:
            self.first_name = value

    class FirstNameLastName(FirstNameOnly):
        # ...

        last_name: Mapped[str]

        # 'inplace' is not used here; calling getter creates a copy
        # of FirstNameOnly.name that is local to FirstNameLastName
        @FirstNameOnly.name.getter
        def name(self) -&gt; str:
            return self.first_name + ' ' + self.last_name

        @name.inplace.setter
        def _name_setter(self, value: str) -&gt; None:
            self.first_name, self.last_name = value.split(' ', 1)

Above, the ``FirstNameLastName`` class refers to the hybrid from
``FirstNameOnly.name`` to repurpose its getter and setter for the subclass.

When overriding :meth:`.hybrid_property.expression` and
:meth:`.hybrid_property.comparator` alone as the first reference to the
superclass, these names conflict with the same-named accessors on the class-
level :class:`.QueryableAttribute` object returned at the class level.  To
override these methods when referring directly to the parent class descriptor,
add the special qualifier :attr:`.hybrid_property.overrides`, which will de-
reference the instrumented attribute back to the hybrid object::

    class FirstNameLastName(FirstNameOnly):
        # ...

        last_name: Mapped[str]

        @FirstNameOnly.name.overrides.expression
        @classmethod
        def name(cls):
            return func.concat(cls.first_name, ' ', cls.last_name)


Hybrid Value Objects
--------------------

Note in our previous example, if we were to compare the ``word_insensitive``
attribute of a ``SearchWord`` instance to a plain Python string, the plain
Python string would not be coerced to lower case - the
``CaseInsensitiveComparator`` we built, being returned by
``@word_insensitive.comparator``, only applies to the SQL side.

A more comprehensive form of the custom comparator is to construct a *Hybrid
Value Object*. This technique applies the target value or expression to a value
object which is then returned by the accessor in all cases.   The value object
allows control of all operations upon the value as well as how compared values
are treated, both on the SQL expression side as well as the Python value side.
Replacing the previous ``CaseInsensitiveComparator`` class with a new
``CaseInsensitiveWord`` class::

    class CaseInsensitiveWord(Comparator):
        "Hybrid value representing a lower case representation of a word."

        def __init__(self, word):
            if isinstance(word, basestring):
                self.word = word.lower()
            elif isinstance(word, CaseInsensitiveWord):
                self.word = word.word
            else:
                self.word = func.lower(word)

        def operate(self, op, other, **kwargs):
            if not isinstance(other, CaseInsensitiveWord):
                other = CaseInsensitiveWord(other)
            return op(self.word, other.word, **kwargs)

        def __clause_element__(self):
            return self.word

        def __str__(self):
            return self.word

        key = 'word'
        "Label to apply to Query tuple results"

Above, the ``CaseInsensitiveWord`` object represents ``self.word``, which may
be a SQL function, or may be a Python native.   By overriding ``operate()`` and
``__clause_element__()`` to work in terms of ``self.word``, all comparison
operations will work against the "converted" form of ``word``, whether it be
SQL side or Python side. Our ``SearchWord`` class can now deliver the
``CaseInsensitiveWord`` object unconditionally from a single hybrid call::

    class SearchWord(Base):
        __tablename__ = 'searchword'
        id: Mapped[int] = mapped_column(primary_key=True)
        word: Mapped[str]

        @hybrid_property
        def word_insensitive(self) -&gt; CaseInsensitiveWord:
            return CaseInsensitiveWord(self.word)

The ``word_insensitive`` attribute now has case-insensitive comparison behavior
universally, including SQL expression vs. Python expression (note the Python
value is converted to lower case on the Python side here):

.. sourcecode:: pycon+sql

    &gt;&gt;&gt; print(select(SearchWord).filter_by(word_insensitive="Trucks"))
    {printsql}SELECT searchword.id AS searchword_id, searchword.word AS searchword_word
    FROM searchword
    WHERE lower(searchword.word) = :lower_1

SQL expression versus SQL expression:

.. sourcecode:: pycon+sql

    &gt;&gt;&gt; from sqlalchemy.orm import aliased
    &gt;&gt;&gt; sw1 = aliased(SearchWord)
    &gt;&gt;&gt; sw2 = aliased(SearchWord)
    &gt;&gt;&gt; print(
    ...     select(sw1.word_insensitive, sw2.word_insensitive).filter(
    ...         sw1.word_insensitive &gt; sw2.word_insensitive
    ...     )
    ... )
    {printsql}SELECT lower(searchword_1.word) AS lower_1,
    lower(searchword_2.word) AS lower_2
    FROM searchword AS searchword_1, searchword AS searchword_2
    WHERE lower(searchword_1.word) &gt; lower(searchword_2.word)

Python only expression::

    &gt;&gt;&gt; ws1 = SearchWord(word="SomeWord")
    &gt;&gt;&gt; ws1.word_insensitive == "sOmEwOrD"
    True
    &gt;&gt;&gt; ws1.word_insensitive == "XOmEwOrX"
    False
    &gt;&gt;&gt; print(ws1.word_insensitive)
    someword

The Hybrid Value pattern is very useful for any kind of value that may have
multiple representations, such as timestamps, time deltas, units of
measurement, currencies and encrypted passwords.

.. seealso::

    `Hybrids and Value Agnostic Types
    &lt;https://techspot.zzzeek.org/2011/10/21/hybrids-and-value-agnostic-types/&gt;`_
    - on the techspot.zzzeek.org blog

    `Value Agnostic Types, Part II
    &lt;https://techspot.zzzeek.org/2011/10/29/value-agnostic-types-part-ii/&gt;`_ -
    on the techspot.zzzeek.org blog</p></div>
        </div>

        <div id="splitTables">
          <table class="children sortable" id="id5981">
  
  
  <tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.ext.hybrid.Comparator.html" class="internal-link" title="sqlalchemy.ext.hybrid.Comparator"><wbr></wbr>Comparator</a></code></td>
    <td>A helper class that allows easy construction of custom :class:`~.orm.interfaces.PropComparator` classes for usage with hybrids.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.ext.hybrid.ExprComparator.html" class="internal-link" title="sqlalchemy.ext.hybrid.ExprComparator"><wbr></wbr>Expr<wbr></wbr>Comparator</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.ext.hybrid.hybrid_method.html" class="internal-link" title="sqlalchemy.ext.hybrid.hybrid_method">hybrid<wbr></wbr>_method</a></code></td>
    <td>A decorator which allows definition of a Python object method with both instance-level and class-level behavior.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.ext.hybrid.hybrid_property.html" class="internal-link" title="sqlalchemy.ext.hybrid.hybrid_property">hybrid<wbr></wbr>_property</a></code></td>
    <td>A decorator which allows definition of a Python descriptor with both instance-level and class-level behavior.</td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.ext.hybrid.HybridExtensionType.html" class="internal-link" title="sqlalchemy.ext.hybrid.HybridExtensionType"><wbr></wbr>Hybrid<wbr></wbr>Extension<wbr></wbr>Type</a></code></td>
    <td><span class="undocumented">No class docstring; 2/2 constants documented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.ext.hybrid._HybridClassLevelAccessor.html" class="internal-link" title="sqlalchemy.ext.hybrid._HybridClassLevelAccessor">_<wbr></wbr>Hybrid<wbr></wbr>Class<wbr></wbr>Level<wbr></wbr>Accessor</a></code></td>
    <td>Describe the object returned by a hybrid_property() when called as a class-level descriptor.</td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.ext.hybrid._HybridComparatorCallableType.html" class="internal-link" title="sqlalchemy.ext.hybrid._HybridComparatorCallableType">_<wbr></wbr>Hybrid<wbr></wbr>Comparator<wbr></wbr>Callable<wbr></wbr>Type</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.ext.hybrid._HybridDeleterType.html" class="internal-link" title="sqlalchemy.ext.hybrid._HybridDeleterType">_<wbr></wbr>Hybrid<wbr></wbr>Deleter<wbr></wbr>Type</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.ext.hybrid._HybridExprCallableType.html" class="internal-link" title="sqlalchemy.ext.hybrid._HybridExprCallableType">_<wbr></wbr>Hybrid<wbr></wbr>Expr<wbr></wbr>Callable<wbr></wbr>Type</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.ext.hybrid._HybridGetterType.html" class="internal-link" title="sqlalchemy.ext.hybrid._HybridGetterType">_<wbr></wbr>Hybrid<wbr></wbr>Getter<wbr></wbr>Type</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.ext.hybrid._HybridSetterType.html" class="internal-link" title="sqlalchemy.ext.hybrid._HybridSetterType">_<wbr></wbr>Hybrid<wbr></wbr>Setter<wbr></wbr>Type</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><code><a href="sqlalchemy.ext.hybrid._HybridUpdaterType.html" class="internal-link" title="sqlalchemy.ext.hybrid._HybridUpdaterType">_<wbr></wbr>Hybrid<wbr></wbr>Updater<wbr></wbr>Type</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_unwrap_classmethod" class="internal-link" title="sqlalchemy.ext.hybrid._unwrap_classmethod">_unwrap<wbr></wbr>_classmethod</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="constant private">
    
    <td>Constant</td>
    <td><code><a href="#_P" class="internal-link" title="sqlalchemy.ext.hybrid._P">_P</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="typevariable private">
    
    <td>Type Variable</td>
    <td><code><a href="#_R" class="internal-link" title="sqlalchemy.ext.hybrid._R">_R</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="typevariable private">
    
    <td>Type Variable</td>
    <td><code><a href="#_T" class="internal-link" title="sqlalchemy.ext.hybrid._T">_T</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="typevariable private">
    
    <td>Type Variable</td>
    <td><code><a href="#_T_co" class="internal-link" title="sqlalchemy.ext.hybrid._T_co">_<wbr></wbr>T_co</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="typevariable private">
    
    <td>Type Variable</td>
    <td><code><a href="#_T_con" class="internal-link" title="sqlalchemy.ext.hybrid._T_con">_<wbr></wbr>T_con</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="typevariable private">
    
    <td>Type Variable</td>
    <td><code><a href="#_TE" class="internal-link" title="sqlalchemy.ext.hybrid._TE">_TE</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
          

            
        </div>

        <div id="childList">
          <div class="basefunction private">
  
  
  <a name="sqlalchemy.ext.hybrid._unwrap_classmethod">
    
  </a>
  <a name="_unwrap_classmethod">
    
  </a>
  <div class="functionHeader">
    
    
    <span class="py-keyword">def</span> <span class="py-defname">_unwrap_classmethod</span><span class="function-signature">(meth: <code><a href="#_T" class="internal-link" title="sqlalchemy.ext.hybrid._T">_T</a></code>) -&gt; <code><a href="#_T" class="internal-link" title="sqlalchemy.ext.hybrid._T">_T</a></code></span>:
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-2.0.8//lib/sqlalchemy/ext/hybrid.py#L1058">
      
      (source)
    </a>
    <a class="headerLink" href="#_unwrap_classmethod" title="sqlalchemy.ext.hybrid._unwrap_classmethod">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="baseconstant private">
  
  
  <a name="sqlalchemy.ext.hybrid._P">
    
  </a>
  <a name="_P">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_P</span> =
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-2.0.8//lib/sqlalchemy/ext/hybrid.py#L870">
      
      (source)
    </a>
    <a class="headerLink" href="#_P" title="sqlalchemy.ext.hybrid._P">
      
      
      ¶
    </a>
  </div>
  <div class="functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code>ParamSpec(<wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">_P</span><span class="rst-variable-quote">'</span>)</code></pre></td></tr></table>
  </div>
</div><div class="basetypevariable private">
  
  
  <a name="sqlalchemy.ext.hybrid._R">
    
  </a>
  <a name="_R">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_R</span> =
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-2.0.8//lib/sqlalchemy/ext/hybrid.py#L871">
      
      (source)
    </a>
    <a class="headerLink" href="#_R" title="sqlalchemy.ext.hybrid._R">
      
      
      ¶
    </a>
  </div>
  <div class="functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code><a href="https://docs.python.org/3/library/typing.html#typing.TypeVar" class="intersphinx-link">TypeVar</a>(<wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">_R</span><span class="rst-variable-quote">'</span>)</code></pre></td></tr></table>
  </div>
</div><div class="basetypevariable private">
  
  
  <a name="sqlalchemy.ext.hybrid._T">
    
  </a>
  <a name="_T">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_T</span> =
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-2.0.8//lib/sqlalchemy/ext/hybrid.py#L872">
      
      (source)
    </a>
    <a class="headerLink" href="#_T" title="sqlalchemy.ext.hybrid._T">
      
      
      ¶
    </a>
  </div>
  <div class="functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code><a href="https://docs.python.org/3/library/typing.html#typing.TypeVar" class="intersphinx-link">TypeVar</a>(<wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">_T</span><span class="rst-variable-quote">'</span>,
        <wbr></wbr>bound=<a href="https://docs.python.org/3/library/typing.html#typing.Any" class="intersphinx-link">Any</a>)</code></pre></td></tr></table>
  </div>
</div><div class="basetypevariable private">
  
  
  <a name="sqlalchemy.ext.hybrid._T_co">
    
  </a>
  <a name="_T_co">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_T_co</span> =
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-2.0.8//lib/sqlalchemy/ext/hybrid.py#L874">
      
      (source)
    </a>
    <a class="headerLink" href="#_T_co" title="sqlalchemy.ext.hybrid._T_co">
      
      
      ¶
    </a>
  </div>
  <div class="functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code><a href="https://docs.python.org/3/library/typing.html#typing.TypeVar" class="intersphinx-link">TypeVar</a>(<wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">_T_co</span><span class="rst-variable-quote">'</span>,
        <wbr></wbr>bound=<a href="https://docs.python.org/3/library/typing.html#typing.Any" class="intersphinx-link">Any</a>, <wbr></wbr>covariant=<a href="https://docs.python.org/3/library/constants.html#True" class="intersphinx-link">True</a>)</code></pre></td></tr></table>
  </div>
</div><div class="basetypevariable private">
  
  
  <a name="sqlalchemy.ext.hybrid._T_con">
    
  </a>
  <a name="_T_con">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_T_con</span> =
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-2.0.8//lib/sqlalchemy/ext/hybrid.py#L875">
      
      (source)
    </a>
    <a class="headerLink" href="#_T_con" title="sqlalchemy.ext.hybrid._T_con">
      
      
      ¶
    </a>
  </div>
  <div class="functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code><a href="https://docs.python.org/3/library/typing.html#typing.TypeVar" class="intersphinx-link">TypeVar</a>(<wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">_T_con</span><span class="rst-variable-quote">'</span>,
        <wbr></wbr>bound=<a href="https://docs.python.org/3/library/typing.html#typing.Any" class="intersphinx-link">Any</a>, <wbr></wbr>contravariant=<a href="https://docs.python.org/3/library/constants.html#True" class="intersphinx-link">True</a>)</code></pre></td></tr></table>
  </div>
</div><div class="basetypevariable private">
  
  
  <a name="sqlalchemy.ext.hybrid._TE">
    
  </a>
  <a name="_TE">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_TE</span> =
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/sqlalchemy-2.0.8//lib/sqlalchemy/ext/hybrid.py#L873">
      
      (source)
    </a>
    <a class="headerLink" href="#_TE" title="sqlalchemy.ext.hybrid._TE">
      
      
      ¶
    </a>
  </div>
  <div class="functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
    <table class="valueTable"><tr class="fieldStart"><td class="fieldName">Value</td></tr><tr><td><pre class="constant-value"><code><a href="https://docs.python.org/3/library/typing.html#typing.TypeVar" class="intersphinx-link">TypeVar</a>(<wbr></wbr><span class="rst-variable-quote">'</span><span class="rst-variable-string">_TE</span><span class="rst-variable-quote">'</span>,
        <wbr></wbr>bound=<a href="https://docs.python.org/3/library/typing.html#typing.Any" class="intersphinx-link">Any</a>)</code></pre></td></tr></table>
  </div>
</div>
        </div>
      
      </div>
    </div>

    <footer class="navbar navbar-default">

  
  <div class="container">
    <a href="index.html">API Documentation</a> for sqlalchemy,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    22.9.1.dev0 at 2023-04-01 01:05:39.
  </div>

  <!-- Search related scripts needs to be loaded at the end of HTML 
    parsing not to introduce overhead and display HTML data asap -->
  <script src="ajax.js" type="text/javascript"></script>
  <script src="searchlib.js" type="text/javascript"></script>
  <script src="search.js" type="text/javascript"></script>

</footer>
  
    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>
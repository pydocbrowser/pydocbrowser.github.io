<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>numpy.linalg.linalg</title>
    <meta name="generator" content="pydoctor 22.9.1"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1 maximum-scale=1" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    <div id="banner">    
    <div>
        <a href="/">Home</a>
        &gt; numpy-1.24.0 <!-- This is a placeholder -->
        
        <!-- (<a href=""&gt;show all versions</a&gt;) -->
    </div>
</div>

    <nav class="navbar navbar-default mainnavbar">
      
  
  <div class="container-fluid">


    <div class="navbar-header">
      
      <div class="navlinks">
        <span class="navbar-brand">
          numpy <a href="index.html">API Documentation</a>
        </span>

        <a href="moduleIndex.html">
          Modules
        </a>

        <a href="classIndex.html">
          Classes
        </a>

        <a href="nameIndex.html">
          Names
        </a>

        <div id="search-box-container">
          <div class="input-group">
            <input id="search-box" type="search" name="search-query" placeholder="Search..." aria-label="Search" minlength="2" class="form-control" autocomplete="off" />
            
            <span class="input-group-btn">
              <a style="display: none;" class="btn btn-default" id="search-clear-button" title="Clear" onclick="clearSearch()"><img src="fonts/x-circle.svg" alt="Clear" /></a>
              <a class="btn btn-default" id="search-help-button" title="Help" onclick="toggleSearchHelpText()"><img src="fonts/info.svg" alt="Help" /></a>
            </span>
          </div>
        </div>

      </div>

      <div id="search-results-container" style="display: none;">
        
        <div id="search-buttons">
          <span class="label label-default" id="search-docstrings-button">
          <label class="checkbox-inline">
            <input type="checkbox" id="toggle-search-in-docstrings-checkbox" value="false" onclick="toggleSearchInDocstrings()">
              search in docstrings
            </input>
          </label>
          </span>
          
        </div>
        
        <noscript>
            <h1>Cannot search: JavaScript is not supported/enabled in your browser.</h1>
        </noscript>

        <div class="hint" id="search-help-box">
          <p class="rst-last">
      
            Search bar offers the following options:
            <ul>   
                <li>
                  <strong>Term presence.</strong> The below example searches for documents that 
                    must contain “foo”, might contain “bar” and must not contain “baz”: <code>+foo bar -baz</code>
                </li> 

                <li>
                  <strong>Wildcards.</strong> The below example searches for documents with words beginning with “foo”: <code>foo*</code>
                </li> 

                <li>
                  <strong>Search in specific fields.</strong> The following search matches all objects 
                  in "twisted.mail" that matches “search”: <code>+qname:twisted.mail.* +search</code>

                  <p>
                    Possible fields: 'name', 'qname' (fully qualified name), 'docstring', and 'kind'.
                    Last two fields are only applicable if "search in docstrings" is enabled.
                  </p>
                </li>

                <li>
                  <strong>Fuzzy matches.</strong> The following search matches all documents 
                  that have a word within 1 edit distance of “foo”: <code>foo~1</code>
                </li>
            </ul>

          </p>
        </div>

        <div id="search-status"> </div>

        <div class="warning" id="search-warn-box" style="display: none;">
          <p class="rst-last"><span id="search-warn"></span></p>
        </div>

        <table id="search-results">
          <!-- Filled dynamically by JS -->
        </table>
        
        <div style="margin-top: 8px;">
          <p>Results provided by <a href="https://lunrjs.com">Lunr.js</a></p>
        </div>
      </div>

    </div>


  </div>
</nav>
    
    <div class="container-fluid">

      <!-- Side navigation -->
      <div class="sidebarcontainer" style="display: none;">
        
        <div class="sidebar"><nav class="sidebar">
  

  <div>

      <div class="thingTitle">
        <span>Module</span>
        <code class="thisobject"><a href="numpy.linalg.linalg.html" class="internal-link" title="This module">linalg</a></code> 
      </div>
      
      <div>
        

        
         

        <div class="childrenKindTitle">Classes</div>
        <ul>
    
    <li class="">
        
        
        

        
            <div class="itemName"><code><a href="numpy.linalg.linalg.LinAlgError.html" class="internal-link" title="numpy.linalg.linalg.LinAlgError"><wbr></wbr>Lin<wbr></wbr>Alg<wbr></wbr>Error</a></code>
            </div>
        

    </li>
</ul>

        <div class="childrenKindTitle">Functions</div>
        <ul>
    
    <li class="">
        
        
        

        
            <div class="itemName"><code><a href="#cholesky" class="internal-link" title="numpy.linalg.linalg.cholesky">cholesky</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#cond" class="internal-link" title="numpy.linalg.linalg.cond">cond</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#det" class="internal-link" title="numpy.linalg.linalg.det">det</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#eig" class="internal-link" title="numpy.linalg.linalg.eig">eig</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#eigh" class="internal-link" title="numpy.linalg.linalg.eigh">eigh</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#eigvals" class="internal-link" title="numpy.linalg.linalg.eigvals">eigvals</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#eigvalsh" class="internal-link" title="numpy.linalg.linalg.eigvalsh">eigvalsh</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#get_linalg_error_extobj" class="internal-link" title="numpy.linalg.linalg.get_linalg_error_extobj">get<wbr></wbr>_linalg<wbr></wbr>_error<wbr></wbr>_extobj</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#inv" class="internal-link" title="numpy.linalg.linalg.inv">inv</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#isComplexType" class="internal-link" title="numpy.linalg.linalg.isComplexType">is<wbr></wbr>Complex<wbr></wbr>Type</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#lstsq" class="internal-link" title="numpy.linalg.linalg.lstsq">lstsq</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#matrix_power" class="internal-link" title="numpy.linalg.linalg.matrix_power">matrix<wbr></wbr>_power</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#matrix_rank" class="internal-link" title="numpy.linalg.linalg.matrix_rank">matrix<wbr></wbr>_rank</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#multi_dot" class="internal-link" title="numpy.linalg.linalg.multi_dot">multi<wbr></wbr>_dot</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#norm" class="internal-link" title="numpy.linalg.linalg.norm">norm</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#pinv" class="internal-link" title="numpy.linalg.linalg.pinv">pinv</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#qr" class="internal-link" title="numpy.linalg.linalg.qr">qr</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#slogdet" class="internal-link" title="numpy.linalg.linalg.slogdet">slogdet</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#solve" class="internal-link" title="numpy.linalg.linalg.solve">solve</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#svd" class="internal-link" title="numpy.linalg.linalg.svd">svd</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#tensorinv" class="internal-link" title="numpy.linalg.linalg.tensorinv">tensorinv</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#tensorsolve" class="internal-link" title="numpy.linalg.linalg.tensorsolve">tensorsolve</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="#transpose" class="internal-link" title="numpy.linalg.linalg.transpose">transpose</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_assert_2d" class="internal-link" title="numpy.linalg.linalg._assert_2d">_assert<wbr></wbr>_2d</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_assert_finite" class="internal-link" title="numpy.linalg.linalg._assert_finite">_assert<wbr></wbr>_finite</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_assert_stacked_2d" class="internal-link" title="numpy.linalg.linalg._assert_stacked_2d">_assert<wbr></wbr>_stacked<wbr></wbr>_2d</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_assert_stacked_square" class="internal-link" title="numpy.linalg.linalg._assert_stacked_square">_assert<wbr></wbr>_stacked<wbr></wbr>_square</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_commonType" class="internal-link" title="numpy.linalg.linalg._commonType">_common<wbr></wbr>Type</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_complexType" class="internal-link" title="numpy.linalg.linalg._complexType">_complex<wbr></wbr>Type</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_cond_dispatcher" class="internal-link" title="numpy.linalg.linalg._cond_dispatcher">_cond<wbr></wbr>_dispatcher</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_convertarray" class="internal-link" title="numpy.linalg.linalg._convertarray">_convertarray</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_determine_error_states" class="internal-link" title="numpy.linalg.linalg._determine_error_states">_determine<wbr></wbr>_error<wbr></wbr>_states</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_eigvalsh_dispatcher" class="internal-link" title="numpy.linalg.linalg._eigvalsh_dispatcher">_eigvalsh<wbr></wbr>_dispatcher</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_is_empty_2d" class="internal-link" title="numpy.linalg.linalg._is_empty_2d">_is<wbr></wbr>_empty<wbr></wbr>_2d</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_lstsq_dispatcher" class="internal-link" title="numpy.linalg.linalg._lstsq_dispatcher">_lstsq<wbr></wbr>_dispatcher</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_makearray" class="internal-link" title="numpy.linalg.linalg._makearray">_makearray</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_matrix_power_dispatcher" class="internal-link" title="numpy.linalg.linalg._matrix_power_dispatcher">_matrix<wbr></wbr>_power<wbr></wbr>_dispatcher</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_matrix_rank_dispatcher" class="internal-link" title="numpy.linalg.linalg._matrix_rank_dispatcher">_matrix<wbr></wbr>_rank<wbr></wbr>_dispatcher</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_multi_dot" class="internal-link" title="numpy.linalg.linalg._multi_dot">_multi<wbr></wbr>_dot</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_multi_dot_matrix_chain_order" class="internal-link" title="numpy.linalg.linalg._multi_dot_matrix_chain_order">_multi<wbr></wbr>_dot<wbr></wbr>_matrix<wbr></wbr>_chain<wbr></wbr>_order</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_multi_dot_three" class="internal-link" title="numpy.linalg.linalg._multi_dot_three">_multi<wbr></wbr>_dot<wbr></wbr>_three</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_multi_svd_norm" class="internal-link" title="numpy.linalg.linalg._multi_svd_norm">_multi<wbr></wbr>_svd<wbr></wbr>_norm</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_multidot_dispatcher" class="internal-link" title="numpy.linalg.linalg._multidot_dispatcher">_multidot<wbr></wbr>_dispatcher</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_norm_dispatcher" class="internal-link" title="numpy.linalg.linalg._norm_dispatcher">_norm<wbr></wbr>_dispatcher</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_pinv_dispatcher" class="internal-link" title="numpy.linalg.linalg._pinv_dispatcher">_pinv<wbr></wbr>_dispatcher</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_qr_dispatcher" class="internal-link" title="numpy.linalg.linalg._qr_dispatcher">_qr<wbr></wbr>_dispatcher</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_raise_linalgerror_eigenvalues_nonconvergence" class="internal-link" title="numpy.linalg.linalg._raise_linalgerror_eigenvalues_nonconvergence">_raise<wbr></wbr>_linalgerror<wbr></wbr>_eigenvalues<wbr></wbr>_nonconvergence</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_raise_linalgerror_lstsq" class="internal-link" title="numpy.linalg.linalg._raise_linalgerror_lstsq">_raise<wbr></wbr>_linalgerror<wbr></wbr>_lstsq</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_raise_linalgerror_nonposdef" class="internal-link" title="numpy.linalg.linalg._raise_linalgerror_nonposdef">_raise<wbr></wbr>_linalgerror<wbr></wbr>_nonposdef</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_raise_linalgerror_qr" class="internal-link" title="numpy.linalg.linalg._raise_linalgerror_qr">_raise<wbr></wbr>_linalgerror<wbr></wbr>_qr</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_raise_linalgerror_singular" class="internal-link" title="numpy.linalg.linalg._raise_linalgerror_singular">_raise<wbr></wbr>_linalgerror<wbr></wbr>_singular</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_raise_linalgerror_svd_nonconvergence" class="internal-link" title="numpy.linalg.linalg._raise_linalgerror_svd_nonconvergence">_raise<wbr></wbr>_linalgerror<wbr></wbr>_svd<wbr></wbr>_nonconvergence</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_realType" class="internal-link" title="numpy.linalg.linalg._realType">_real<wbr></wbr>Type</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_solve_dispatcher" class="internal-link" title="numpy.linalg.linalg._solve_dispatcher">_solve<wbr></wbr>_dispatcher</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_svd_dispatcher" class="internal-link" title="numpy.linalg.linalg._svd_dispatcher">_svd<wbr></wbr>_dispatcher</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_tensorinv_dispatcher" class="internal-link" title="numpy.linalg.linalg._tensorinv_dispatcher">_tensorinv<wbr></wbr>_dispatcher</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_tensorsolve_dispatcher" class="internal-link" title="numpy.linalg.linalg._tensorsolve_dispatcher">_tensorsolve<wbr></wbr>_dispatcher</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_to_native_byte_order" class="internal-link" title="numpy.linalg.linalg._to_native_byte_order">_to<wbr></wbr>_native<wbr></wbr>_byte<wbr></wbr>_order</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_unary_dispatcher" class="internal-link" title="numpy.linalg.linalg._unary_dispatcher">_unary<wbr></wbr>_dispatcher</a></code>
            </div>
        

    </li>
</ul> 

        
         

        <div class="childrenKindTitle">Variables</div>
        <ul>
    
    <li class="">
        
        
        

        
            <div class="itemName"><code><a href="#array_function_dispatch" class="internal-link" title="numpy.linalg.linalg.array_function_dispatch">array<wbr></wbr>_function<wbr></wbr>_dispatch</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_complex_types_map" class="internal-link" title="numpy.linalg.linalg._complex_types_map">_complex<wbr></wbr>_types<wbr></wbr>_map</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_linalg_error_extobj" class="internal-link" title="numpy.linalg.linalg._linalg_error_extobj">_linalg<wbr></wbr>_error<wbr></wbr>_extobj</a></code>
            </div>
        

    </li><li class="private">
        
        
        

        
            <div class="itemName"><code><a href="#_real_types_map" class="internal-link" title="numpy.linalg.linalg._real_types_map">_real<wbr></wbr>_types<wbr></wbr>_map</a></code>
            </div>
        

    </li>
</ul> 

        
         
        
      </div>
  </div><div>

      <div class="thingTitle">
        <span>Package</span>
        <code><a href="numpy.linalg.html" class="internal-link" title="The parent of this module">linalg</a></code> 
      </div>
      
      <div>
        

        <div class="childrenKindTitle">Modules</div>
        <ul>
    
    <li class="">
        
        
        

        
            <div class="itemName"><code><a href="numpy.linalg.tests.html" class="internal-link" title="numpy.linalg.tests">tests</a></code>
            </div>
        

    </li><li class=" thisobject">
        
        
        

        
            <div class="itemName"><code><a href="numpy.linalg.linalg.html" class="internal-link" title="numpy.linalg.linalg">linalg</a></code>
            </div>
        

    </li><li class="">
        
        
        

        
            <div class="itemName"><code><a href="numpy.linalg.setup.html" class="internal-link" title="numpy.linalg.setup">setup</a></code>
            </div>
        

    </li>
</ul> 

        
        

        
         

        
         

        <div class="childrenKindTitle">Variables</div>
        <ul>
    
    <li class="">
        
        
        

        
            <div class="itemName"><code><a href="numpy.linalg.html#test" class="internal-link" title="numpy.linalg.test">test</a></code>
            </div>
        

    </li>
</ul> 

        
         
        
      </div>
  </div>

</nav>
        </div>
        <div id="collapseSideBar">
          <a class="btn btn-link" onclick="toggleSideBarCollapse()" title="Toggle Sidebar Collapse">
          </a>
        </div> 
        <script src="sidebartoggle.js" type="text/javascript"></script>
       
      </div>

      <div id="main" class="">
        

        

        <div class="page-header">
          <h1 class="module"><code><code><a href="index.html" class="internal-link">numpy</a></code><wbr></wbr>.<code><a href="numpy.linalg.html" class="internal-link" title="numpy.linalg">linalg</a></code><wbr></wbr>.<code><a href="numpy.linalg.linalg.html" class="internal-link" title="numpy.linalg.linalg">linalg</a></code></code></h1>
          <div id="showPrivate">
            <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
          </div>
        </div>

        <div class="categoryHeader">
          module documentation
        </div>

        <div class="extrasDocstring">
          <a href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py" class="sourceLink">(source)</a>
          <p></p>
        </div>

        <div class="moduleDocstring">
          <div><p>Lite version of scipy.linalg.</p>
<div class="rst-admonition rst-admonition-notes">
<p class="rst-first rst-admonition-title">Notes</p>
<p class="rst-last">This module is a lite version of the linalg.py module in SciPy which
contains high-level Python interface to the LAPACK library.  The lite
version only accesses the following LAPACK functions: dgesv, zgesv,
dgeev, zgeev, dgesdd, zgesdd, dgelsd, zgelsd, dsyevd, zheevd, dgetrf,
zgetrf, dpotrf, zpotrf, dgeqrf, zgeqrf, zungqr, dorgqr.</p>
</div>
</div>
        </div>

        <div id="splitTables">
          <table class="children sortable" id="id1706">
  
  
  <tr class="exception">
    
    <td>Exception</td>
    <td><code><a href="numpy.linalg.linalg.LinAlgError.html" class="internal-link" title="numpy.linalg.linalg.LinAlgError"><wbr></wbr>Lin<wbr></wbr>Alg<wbr></wbr>Error</a></code></td>
    <td>Generic Python-exception-derived object raised by linalg functions.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#cholesky" class="internal-link" title="numpy.linalg.linalg.cholesky">cholesky</a></code></td>
    <td>Cholesky decomposition.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#cond" class="internal-link" title="numpy.linalg.linalg.cond">cond</a></code></td>
    <td>Compute the condition number of a matrix.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#det" class="internal-link" title="numpy.linalg.linalg.det">det</a></code></td>
    <td>Compute the determinant of an array.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#eig" class="internal-link" title="numpy.linalg.linalg.eig">eig</a></code></td>
    <td>Compute the eigenvalues and right eigenvectors of a square array.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#eigh" class="internal-link" title="numpy.linalg.linalg.eigh">eigh</a></code></td>
    <td>Return the eigenvalues and eigenvectors of a complex Hermitian (conjugate symmetric) or a real symmetric matrix.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#eigvals" class="internal-link" title="numpy.linalg.linalg.eigvals">eigvals</a></code></td>
    <td>Compute the eigenvalues of a general matrix.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#eigvalsh" class="internal-link" title="numpy.linalg.linalg.eigvalsh">eigvalsh</a></code></td>
    <td>Compute the eigenvalues of a complex Hermitian or real symmetric matrix.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#get_linalg_error_extobj" class="internal-link" title="numpy.linalg.linalg.get_linalg_error_extobj">get<wbr></wbr>_linalg<wbr></wbr>_error<wbr></wbr>_extobj</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#inv" class="internal-link" title="numpy.linalg.linalg.inv">inv</a></code></td>
    <td>Compute the (multiplicative) inverse of a matrix.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#isComplexType" class="internal-link" title="numpy.linalg.linalg.isComplexType">is<wbr></wbr>Complex<wbr></wbr>Type</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#lstsq" class="internal-link" title="numpy.linalg.linalg.lstsq">lstsq</a></code></td>
    <td>Return the least-squares solution to a linear matrix equation.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#matrix_power" class="internal-link" title="numpy.linalg.linalg.matrix_power">matrix<wbr></wbr>_power</a></code></td>
    <td>Raise a square matrix to the (integer) power <code>n</code>.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#matrix_rank" class="internal-link" title="numpy.linalg.linalg.matrix_rank">matrix<wbr></wbr>_rank</a></code></td>
    <td>Return matrix rank of array using SVD method</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#multi_dot" class="internal-link" title="numpy.linalg.linalg.multi_dot">multi<wbr></wbr>_dot</a></code></td>
    <td>Compute the dot product of two or more arrays in a single function call, while automatically selecting the fastest evaluation order.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#norm" class="internal-link" title="numpy.linalg.linalg.norm">norm</a></code></td>
    <td>Matrix or vector norm.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#pinv" class="internal-link" title="numpy.linalg.linalg.pinv">pinv</a></code></td>
    <td>Compute the (Moore-Penrose) pseudo-inverse of a matrix.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#qr" class="internal-link" title="numpy.linalg.linalg.qr">qr</a></code></td>
    <td>Compute the qr factorization of a matrix.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#slogdet" class="internal-link" title="numpy.linalg.linalg.slogdet">slogdet</a></code></td>
    <td>Compute the sign and (natural) logarithm of the determinant of an array.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#solve" class="internal-link" title="numpy.linalg.linalg.solve">solve</a></code></td>
    <td>Solve a linear matrix equation, or system of linear scalar equations.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#svd" class="internal-link" title="numpy.linalg.linalg.svd">svd</a></code></td>
    <td>Singular Value Decomposition.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#tensorinv" class="internal-link" title="numpy.linalg.linalg.tensorinv">tensorinv</a></code></td>
    <td>Compute the 'inverse' of an N-dimensional array.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#tensorsolve" class="internal-link" title="numpy.linalg.linalg.tensorsolve">tensorsolve</a></code></td>
    <td>Solve the tensor equation <tt class="rst-docutils literal">a x = b</tt> for x.</td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#transpose" class="internal-link" title="numpy.linalg.linalg.transpose">transpose</a></code></td>
    <td>Transpose each matrix in a stack of matrices.</td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><code><a href="#array_function_dispatch" class="internal-link" title="numpy.linalg.linalg.array_function_dispatch">array<wbr></wbr>_function<wbr></wbr>_dispatch</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_assert_2d" class="internal-link" title="numpy.linalg.linalg._assert_2d">_assert<wbr></wbr>_2d</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_assert_finite" class="internal-link" title="numpy.linalg.linalg._assert_finite">_assert<wbr></wbr>_finite</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_assert_stacked_2d" class="internal-link" title="numpy.linalg.linalg._assert_stacked_2d">_assert<wbr></wbr>_stacked<wbr></wbr>_2d</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_assert_stacked_square" class="internal-link" title="numpy.linalg.linalg._assert_stacked_square">_assert<wbr></wbr>_stacked<wbr></wbr>_square</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_commonType" class="internal-link" title="numpy.linalg.linalg._commonType">_common<wbr></wbr>Type</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_complexType" class="internal-link" title="numpy.linalg.linalg._complexType">_complex<wbr></wbr>Type</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_cond_dispatcher" class="internal-link" title="numpy.linalg.linalg._cond_dispatcher">_cond<wbr></wbr>_dispatcher</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_convertarray" class="internal-link" title="numpy.linalg.linalg._convertarray">_convertarray</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_determine_error_states" class="internal-link" title="numpy.linalg.linalg._determine_error_states">_determine<wbr></wbr>_error<wbr></wbr>_states</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_eigvalsh_dispatcher" class="internal-link" title="numpy.linalg.linalg._eigvalsh_dispatcher">_eigvalsh<wbr></wbr>_dispatcher</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_is_empty_2d" class="internal-link" title="numpy.linalg.linalg._is_empty_2d">_is<wbr></wbr>_empty<wbr></wbr>_2d</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_lstsq_dispatcher" class="internal-link" title="numpy.linalg.linalg._lstsq_dispatcher">_lstsq<wbr></wbr>_dispatcher</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_makearray" class="internal-link" title="numpy.linalg.linalg._makearray">_makearray</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_matrix_power_dispatcher" class="internal-link" title="numpy.linalg.linalg._matrix_power_dispatcher">_matrix<wbr></wbr>_power<wbr></wbr>_dispatcher</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_matrix_rank_dispatcher" class="internal-link" title="numpy.linalg.linalg._matrix_rank_dispatcher">_matrix<wbr></wbr>_rank<wbr></wbr>_dispatcher</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_multi_dot" class="internal-link" title="numpy.linalg.linalg._multi_dot">_multi<wbr></wbr>_dot</a></code></td>
    <td>Actually do the multiplication with the given order.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_multi_dot_matrix_chain_order" class="internal-link" title="numpy.linalg.linalg._multi_dot_matrix_chain_order">_multi<wbr></wbr>_dot<wbr></wbr>_matrix<wbr></wbr>_chain<wbr></wbr>_order</a></code></td>
    <td>Return a np.array that encodes the optimal order of mutiplications.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_multi_dot_three" class="internal-link" title="numpy.linalg.linalg._multi_dot_three">_multi<wbr></wbr>_dot<wbr></wbr>_three</a></code></td>
    <td>Find the best order for three arrays and do the multiplication.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_multi_svd_norm" class="internal-link" title="numpy.linalg.linalg._multi_svd_norm">_multi<wbr></wbr>_svd<wbr></wbr>_norm</a></code></td>
    <td>Compute a function of the singular values of the 2-D matrices in <code>x</code>.</td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_multidot_dispatcher" class="internal-link" title="numpy.linalg.linalg._multidot_dispatcher">_multidot<wbr></wbr>_dispatcher</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_norm_dispatcher" class="internal-link" title="numpy.linalg.linalg._norm_dispatcher">_norm<wbr></wbr>_dispatcher</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_pinv_dispatcher" class="internal-link" title="numpy.linalg.linalg._pinv_dispatcher">_pinv<wbr></wbr>_dispatcher</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_qr_dispatcher" class="internal-link" title="numpy.linalg.linalg._qr_dispatcher">_qr<wbr></wbr>_dispatcher</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_raise_linalgerror_eigenvalues_nonconvergence" class="internal-link" title="numpy.linalg.linalg._raise_linalgerror_eigenvalues_nonconvergence">_raise<wbr></wbr>_linalgerror<wbr></wbr>_eigenvalues<wbr></wbr>_nonconvergence</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_raise_linalgerror_lstsq" class="internal-link" title="numpy.linalg.linalg._raise_linalgerror_lstsq">_raise<wbr></wbr>_linalgerror<wbr></wbr>_lstsq</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_raise_linalgerror_nonposdef" class="internal-link" title="numpy.linalg.linalg._raise_linalgerror_nonposdef">_raise<wbr></wbr>_linalgerror<wbr></wbr>_nonposdef</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_raise_linalgerror_qr" class="internal-link" title="numpy.linalg.linalg._raise_linalgerror_qr">_raise<wbr></wbr>_linalgerror<wbr></wbr>_qr</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_raise_linalgerror_singular" class="internal-link" title="numpy.linalg.linalg._raise_linalgerror_singular">_raise<wbr></wbr>_linalgerror<wbr></wbr>_singular</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_raise_linalgerror_svd_nonconvergence" class="internal-link" title="numpy.linalg.linalg._raise_linalgerror_svd_nonconvergence">_raise<wbr></wbr>_linalgerror<wbr></wbr>_svd<wbr></wbr>_nonconvergence</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_realType" class="internal-link" title="numpy.linalg.linalg._realType">_real<wbr></wbr>Type</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_solve_dispatcher" class="internal-link" title="numpy.linalg.linalg._solve_dispatcher">_solve<wbr></wbr>_dispatcher</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_svd_dispatcher" class="internal-link" title="numpy.linalg.linalg._svd_dispatcher">_svd<wbr></wbr>_dispatcher</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_tensorinv_dispatcher" class="internal-link" title="numpy.linalg.linalg._tensorinv_dispatcher">_tensorinv<wbr></wbr>_dispatcher</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_tensorsolve_dispatcher" class="internal-link" title="numpy.linalg.linalg._tensorsolve_dispatcher">_tensorsolve<wbr></wbr>_dispatcher</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_to_native_byte_order" class="internal-link" title="numpy.linalg.linalg._to_native_byte_order">_to<wbr></wbr>_native<wbr></wbr>_byte<wbr></wbr>_order</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_unary_dispatcher" class="internal-link" title="numpy.linalg.linalg._unary_dispatcher">_unary<wbr></wbr>_dispatcher</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><code><a href="#_complex_types_map" class="internal-link" title="numpy.linalg.linalg._complex_types_map">_complex<wbr></wbr>_types<wbr></wbr>_map</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><code><a href="#_linalg_error_extobj" class="internal-link" title="numpy.linalg.linalg._linalg_error_extobj">_linalg<wbr></wbr>_error<wbr></wbr>_extobj</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><code><a href="#_real_types_map" class="internal-link" title="numpy.linalg.linalg._real_types_map">_real<wbr></wbr>_types<wbr></wbr>_map</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
          

            
        </div>

        <div id="childList">
          <div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.cholesky">
    
  </a>
  <a name="cholesky">
    
  </a>
  <div class="functionHeader">
    @<a href="#array_function_dispatch" class="internal-link" title="numpy.linalg.linalg.array_function_dispatch">array_function_dispatch</a>(<wbr></wbr><a href="#_unary_dispatcher" class="internal-link" title="numpy.linalg.linalg._unary_dispatcher">_unary_dispatcher</a>)<br />
    <span class="py-keyword">def</span> <span class="py-defname">cholesky</span>(a):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L665">
      
      (source)
    </a>
    <a class="headerLink" href="#cholesky" title="numpy.linalg.linalg.cholesky">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Cholesky decomposition.</p>
<p>Return the Cholesky decomposition, <code>L * L.H</code>, of the square matrix <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>,
where <code>L</code> is lower-triangular and .H is the conjugate transpose operator
(which is the ordinary transpose if <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> is real-valued).  <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> must be
Hermitian (symmetric if real-valued) and positive-definite. No
checking is performed to verify whether <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> is Hermitian or not.
In addition, only the lower-triangular and diagonal elements of <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>
are used. Only <code>L</code> is actually returned.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<dl class="rst-last rst-docutils">
<dt><code>scipy.linalg.cholesky</code></dt>
<dd>Similar function in SciPy.</dd>
<dt><code>scipy.linalg.cholesky_banded</code></dt>
<dd>Cholesky decompose a banded Hermitian positive-definite matrix.</dd>
<dt><code>scipy.linalg.cho_factor</code></dt>
<dd>Cholesky decomposition of a matrix, to use in <code>scipy.linalg.cho_solve</code>.</dd>
</dl>
</div>
<div class="rst-admonition rst-admonition-notes">
<p class="rst-first rst-admonition-title">Notes</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.8.0.</span></div>
<p>Broadcasting rules apply, see the <code><a href="numpy.linalg.html" class="internal-link">numpy.linalg</a></code> documentation for
details.</p>
<p>The Cholesky decomposition is often used as a fast way of solving</p>
<div class="rst-formula">
<i>A</i><b>x</b> = <b>b</b>
</div>
<p>(when <code><a href="numpy.core.tests.test_scalarinherit.A.html" class="internal-link" title="numpy.core.tests.test_scalarinherit.A">A</a></code> is both Hermitian/symmetric and positive-definite).</p>
<p>First, we solve for <span class="rst-formula"><b>y</b></span> in</p>
<div class="rst-formula">
<i>L</i><b>y</b> = <b>b</b>, 
</div>
<p>and then for <span class="rst-formula"><b>x</b></span> in</p>
<div class="rst-last rst-formula">
<i>L</i>.<i>H</i><b>x</b> = <b>y</b>.
</div>
</div>
<div class="rst-admonition rst-admonition-examples">
<p class="rst-first rst-admonition-title">Examples</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>A = np.array([[1,-2j],[2j,5]])
<span class="py-prompt">&gt;&gt;&gt; </span>A
<span class="py-output">array([[ 1.+0.j, -0.-2.j],</span>
<span class="py-output">       [ 0.+2.j,  5.+0.j]])</span>
<span class="py-prompt">&gt;&gt;&gt; </span>L = np.linalg.cholesky(A)
<span class="py-prompt">&gt;&gt;&gt; </span>L
<span class="py-output">array([[1.+0.j, 0.+0.j],</span>
<span class="py-output">       [0.+2.j, 1.+0.j]])</span>
<span class="py-prompt">&gt;&gt;&gt; </span>np.dot(L, L.T.conj()) <span class="py-comment"># verify that L * L.H = A</span>
<span class="py-output">array([[1.+0.j, 0.-2.j],</span>
<span class="py-output">       [0.+2.j, 5.+0.j]])</span>
<span class="py-prompt">&gt;&gt;&gt; </span>A = [[1,-2j],[2j,5]] <span class="py-comment"># what happens if A is only array_like?</span>
<span class="py-prompt">&gt;&gt;&gt; </span>np.linalg.cholesky(A) <span class="py-comment"># an ndarray object is returned</span>
<span class="py-output">array([[1.+0.j, 0.+0.j],</span>
<span class="py-output">       [0.+2.j, 1.+0.j]])</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># But a matrix object is returned if A is a matrix object</span>
<span class="py-prompt">&gt;&gt;&gt; </span>np.linalg.cholesky(np.matrix(A))
<span class="py-output">matrix([[ 1.+0.j,  0.+0.j],</span>
<span class="py-output">        [ 0.+2.j,  1.+0.j]])</span>
</pre></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">a:</span>(<code>...</code>, <code>M</code>, <code>M)</code><blockquote>
array_like</blockquote>
</td><td class="fieldArgDesc">Hermitian (symmetric if all elements are real), positive-definite
input matrix.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">(<code>...</code>, <code>M</code>, <code>M)</code><blockquote>
array_like</blockquote>
</td><td class="fieldArgDesc"><strong>L</strong> - Lower-triangular Cholesky factor of <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>.  Returns a matrix object if
<code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> is a matrix object.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Raises</td></tr><tr><td class="fieldArgContainer"><code><a href="numpy.linalg.linalg.LinAlgError.html" class="internal-link" title="numpy.linalg.linalg.LinAlgError">LinAlgError</a></code></td><td>If the decomposition fails, for example, if <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> is not
positive-definite.</td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.cond">
    
  </a>
  <a name="cond">
    
  </a>
  <div class="functionHeader">
    @<a href="#array_function_dispatch" class="internal-link" title="numpy.linalg.linalg.array_function_dispatch">array_function_dispatch</a>(<wbr></wbr><a href="#_cond_dispatcher" class="internal-link" title="numpy.linalg.linalg._cond_dispatcher">_cond_dispatcher</a>)<br />
    <span class="py-keyword">def</span> <span class="py-defname">cond</span>(x, p=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L1663">
      
      (source)
    </a>
    <a class="headerLink" href="#cond" title="numpy.linalg.linalg.cond">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Compute the condition number of a matrix.</p>
<p>This function is capable of returning the condition number using
one of seven different norms, depending on the value of <code><a href="numpy.array_api.tests.test_validation.html#p" class="internal-link" title="numpy.array_api.tests.test_validation.p">p</a></code> (see
Parameters below).</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#norm" class="intersphinx-link">numpy.linalg.norm</a></code></p>
</div>
<div class="rst-admonition rst-admonition-notes">
<p class="rst-first rst-admonition-title">Notes</p>
<p class="rst-last">The condition number of <code>x</code> is defined as the norm of <code>x</code> times the
norm of the inverse of <code>x</code> <a class="rst-footnote-reference" href="#rst-footnote-1" id="rst-footnote-reference-1">[1]</a>; the norm can be the usual L2-norm
(root-of-sum-of-squares) or one of a number of other matrix norms.</p>
</div>
<div class="rst-admonition rst-admonition-references">
<p class="rst-first rst-admonition-title">References</p>
<table class="rst-last rst-docutils footnote" frame="void" id="rst-footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="rst-label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>G. Strang, <em>Linear Algebra and Its Applications</em>, Orlando, FL,
Academic Press, Inc., 1980, pg. 285.</td></tr>
</tbody>
</table>
</div>
<div class="rst-admonition rst-admonition-examples">
<p class="rst-first rst-admonition-title">Examples</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> numpy <span class="py-keyword">import</span> linalg <span class="py-keyword">as</span> LA
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[1, 0, -1], [0, 1, 0], [1, 0, 1]])
<span class="py-prompt">&gt;&gt;&gt; </span>a
<span class="py-output">array([[ 1,  0, -1],</span>
<span class="py-output">       [ 0,  1,  0],</span>
<span class="py-output">       [ 1,  0,  1]])</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.cond(a)
<span class="py-output">1.4142135623730951</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.cond(a, <span class="py-string">'fro'</span>)
<span class="py-output">3.1622776601683795</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.cond(a, np.inf)
<span class="py-output">2.0</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.cond(a, -np.inf)
<span class="py-output">1.0</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.cond(a, 1)
<span class="py-output">2.0</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.cond(a, -1)
<span class="py-output">1.0</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.cond(a, 2)
<span class="py-output">1.4142135623730951</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.cond(a, -2)
<span class="py-output">0.70710678118654746 # may vary</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-builtin">min</span>(LA.svd(a, compute_uv=<span class="py-builtin">False</span>))*<span class="py-builtin">min</span>(LA.svd(LA.inv(a), compute_uv=<span class="py-builtin">False</span>))
<span class="py-output">0.70710678118654746 # may vary</span>
</pre></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">x:</span>(<code>...</code>, <code>M</code>, <code>N)</code><blockquote>
array_like</blockquote>
</td><td class="fieldArgDesc">The matrix whose condition number is sought.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">p:</span><span class="literal">{None</span>, <span class="literal">1</span>, <span class="literal">-1</span>, <span class="literal">2</span>, <span class="literal">-2</span>, <span class="literal">inf</span>, <span class="literal">-inf</span>, <span class="literal">'fro'</span><span class="literal">}</span>, <em>optional</em></td><td class="fieldArgDesc"><p>Order of the norm used in the condition number computation:</p>
<table border="1" class="rst-docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<thead valign="bottom">
<tr><th class="rst-head">p</th>
<th class="rst-head">norm for matrices</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>None</td>
<td>2-norm, computed directly using the <tt class="rst-docutils literal">SVD</tt></td>
</tr>
<tr><td>'fro'</td>
<td>Frobenius norm</td>
</tr>
<tr><td>inf</td>
<td>max(sum(abs(x), axis=1))</td>
</tr>
<tr><td>-inf</td>
<td>min(sum(abs(x), axis=1))</td>
</tr>
<tr><td>1</td>
<td>max(sum(abs(x), axis=0))</td>
</tr>
<tr><td>-1</td>
<td>min(sum(abs(x), axis=0))</td>
</tr>
<tr><td>2</td>
<td>2-norm (largest sing. value)</td>
</tr>
<tr><td>-2</td>
<td>smallest singular value</td>
</tr>
</tbody>
</table>
<p>inf means the <code>numpy.inf</code> object, and the Frobenius norm is
the root-of-sum-of-squares norm.</p>
</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer"><span class="literal">{float</span>, <span class="literal">inf}</span></td><td class="fieldArgDesc"><strong>c</strong> - The condition number of the matrix. May be infinite.</td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.det">
    
  </a>
  <a name="det">
    
  </a>
  <div class="functionHeader">
    @<a href="#array_function_dispatch" class="internal-link" title="numpy.linalg.linalg.array_function_dispatch">array_function_dispatch</a>(<wbr></wbr><a href="#_unary_dispatcher" class="internal-link" title="numpy.linalg.linalg._unary_dispatcher">_unary_dispatcher</a>)<br />
    <span class="py-keyword">def</span> <span class="py-defname">det</span>(a):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L2085">
      
      (source)
    </a>
    <a class="headerLink" href="#det" title="numpy.linalg.linalg.det">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Compute the determinant of an array.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<dl class="rst-last rst-docutils">
<dt><code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#slogdet" class="intersphinx-link">slogdet</a></code></dt>
<dd>Another way to represent the determinant, more suitable for large matrices where underflow/overflow may occur.</dd>
<dt><code>scipy.linalg.det</code></dt>
<dd>Similar function in SciPy.</dd>
</dl>
</div>
<div class="rst-admonition rst-admonition-notes">
<p class="rst-first rst-admonition-title">Notes</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.8.0.</span></div>
<p>Broadcasting rules apply, see the <code><a href="numpy.linalg.html" class="internal-link">numpy.linalg</a></code> documentation for
details.</p>
<p class="rst-last">The determinant is computed via LU factorization using the LAPACK
routine <tt class="rst-docutils literal">z/dgetrf</tt>.</p>
</div>
<div class="rst-admonition rst-admonition-examples">
<p class="rst-first rst-admonition-title">Examples</p>
<p>The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[1, 2], [3, 4]])
<span class="py-prompt">&gt;&gt;&gt; </span>np.linalg.det(a)
<span class="py-output">-2.0 # may vary</span>
</pre><p>Computing determinants for a stack of matrices:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
<span class="py-prompt">&gt;&gt;&gt; </span>a.shape
<span class="py-output">(3, 2, 2)</span>
<span class="py-prompt">&gt;&gt;&gt; </span>np.linalg.det(a)
<span class="py-output">array([-2., -3., -8.])</span>
</pre></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">a:</span>(<code>...</code>, <code>M</code>, <code>M)</code><blockquote>
array_like</blockquote>
</td><td class="fieldArgDesc">Input array to compute determinants for.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">(<code>...)</code><blockquote>
array_like</blockquote>
</td><td class="fieldArgDesc"><strong>det</strong> - Determinant of <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>.</td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.eig">
    
  </a>
  <a name="eig">
    
  </a>
  <div class="functionHeader">
    @<a href="#array_function_dispatch" class="internal-link" title="numpy.linalg.linalg.array_function_dispatch">array_function_dispatch</a>(<wbr></wbr><a href="#_unary_dispatcher" class="internal-link" title="numpy.linalg.linalg._unary_dispatcher">_unary_dispatcher</a>)<br />
    <span class="py-keyword">def</span> <span class="py-defname">eig</span>(a):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L1168">
      
      (source)
    </a>
    <a class="headerLink" href="#eig" title="numpy.linalg.linalg.eig">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Compute the eigenvalues and right eigenvectors of a square array.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<dl class="rst-last rst-docutils">
<dt><code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#eigvals" class="intersphinx-link">eigvals</a></code></dt>
<dd>eigenvalues of a non-symmetric array.</dd>
<dt><code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#eigh" class="intersphinx-link">eigh</a></code></dt>
<dd>eigenvalues and eigenvectors of a real symmetric or complex Hermitian (conjugate symmetric) array.</dd>
<dt><code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#eigvalsh" class="intersphinx-link">eigvalsh</a></code></dt>
<dd>eigenvalues of a real symmetric or complex Hermitian (conjugate symmetric) array.</dd>
<dt><code>scipy.linalg.eig</code></dt>
<dd>Similar function in SciPy that also solves the generalized eigenvalue problem.</dd>
<dt><code>scipy.linalg.schur</code></dt>
<dd>Best choice for unitary and other non-Hermitian normal matrices.</dd>
</dl>
</div>
<div class="rst-admonition rst-admonition-notes">
<p class="rst-first rst-admonition-title">Notes</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.8.0.</span></div>
<p>Broadcasting rules apply, see the <code><a href="numpy.linalg.html" class="internal-link">numpy.linalg</a></code> documentation for
details.</p>
<p>This is implemented using the <tt class="rst-docutils literal">_geev</tt> LAPACK routines which compute
the eigenvalues and eigenvectors of general square arrays.</p>
<p>The number <code>w</code> is an eigenvalue of <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> if there exists a vector
<code>v</code> such that <tt class="rst-docutils literal">a @ v = w * v</tt>. Thus, the arrays <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>, <code>w</code>, and
<code>v</code> satisfy the equations <tt class="rst-docutils literal">a @ <span class="pre">v[:,i]</span> = w[i] * <span class="pre">v[:,i]</span></tt>
for <span class="rst-formula"><i>i</i> ∈ {0, ..., <i>M</i> − 1}</span>.</p>
<p>The array <code>v</code> of eigenvectors may not be of maximum rank, that is, some
of the columns may be linearly dependent, although round-off error may
obscure that fact. If the eigenvalues are all different, then theoretically
the eigenvectors are linearly independent and <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> can be diagonalized by
a similarity transformation using <code>v</code>, i.e, <tt class="rst-docutils literal">inv(v) @ a @ v</tt> is diagonal.</p>
<p>For non-Hermitian normal matrices the SciPy function <code>scipy.linalg.schur</code>
is preferred because the matrix <code>v</code> is guaranteed to be unitary, which is
not the case when using <code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#eig" class="intersphinx-link">eig</a></code>. The Schur factorization produces an
upper triangular matrix rather than a diagonal matrix, but for normal
matrices only the diagonal of the upper triangular matrix is needed, the
rest is roundoff error.</p>
<p class="rst-last">Finally, it is emphasized that <code>v</code> consists of the <em>right</em> (as in
right-hand side) eigenvectors of <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>.  A vector <code>y</code> satisfying
<tt class="rst-docutils literal">y.T @ a = z * y.T</tt> for some number <code>z</code> is called a <em>left</em>
eigenvector of <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>, and, in general, the left and right eigenvectors
of a matrix are not necessarily the (perhaps conjugate) transposes
of each other.</p>
</div>
<div class="rst-admonition rst-admonition-references">
<p class="rst-first rst-admonition-title">References</p>
<p class="rst-last">G. Strang, <em>Linear Algebra and Its Applications</em>, 2nd Ed., Orlando, FL,
Academic Press, Inc., 1980, Various pp.</p>
</div>
<div class="rst-admonition rst-admonition-examples">
<p class="rst-first rst-admonition-title">Examples</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> numpy <span class="py-keyword">import</span> linalg <span class="py-keyword">as</span> LA</pre><p>(Almost) trivial example with real e-values and e-vectors.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>w, v = LA.eig(np.diag((1, 2, 3)))
<span class="py-prompt">&gt;&gt;&gt; </span>w; v
<span class="py-output">array([1., 2., 3.])</span>
<span class="py-output">array([[1., 0., 0.],</span>
<span class="py-output">       [0., 1., 0.],</span>
<span class="py-output">       [0., 0., 1.]])</span>
</pre><p>Real matrix possessing complex e-values and e-vectors; note that the
e-values are complex conjugates of each other.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>w, v = LA.eig(np.array([[1, -1], [1, 1]]))
<span class="py-prompt">&gt;&gt;&gt; </span>w; v
<span class="py-output">array([1.+1.j, 1.-1.j])</span>
<span class="py-output">array([[0.70710678+0.j        , 0.70710678-0.j        ],</span>
<span class="py-output">       [0.        -0.70710678j, 0.        +0.70710678j]])</span>
</pre><p>Complex-valued matrix with real e-values (but complex-valued e-vectors);
note that <tt class="rst-docutils literal"><span class="pre">a.conj().T</span> == a</tt>, i.e., <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> is Hermitian.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[1, 1j], [-1j, 1]])
<span class="py-prompt">&gt;&gt;&gt; </span>w, v = LA.eig(a)
<span class="py-prompt">&gt;&gt;&gt; </span>w; v
<span class="py-output">array([2.+0.j, 0.+0.j])</span>
<span class="py-output">array([[ 0.        +0.70710678j,  0.70710678+0.j        ], # may vary</span>
<span class="py-output">       [ 0.70710678+0.j        , -0.        +0.70710678j]])</span>
</pre><p>Be careful about round-off error!</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[1 + 1e-9, 0], [0, 1 - 1e-9]])
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># Theor. e-values are 1 +/- 1e-9</span>
<span class="py-prompt">&gt;&gt;&gt; </span>w, v = LA.eig(a)
<span class="py-prompt">&gt;&gt;&gt; </span>w; v
<span class="py-output">array([1., 1.])</span>
<span class="py-output">array([[1., 0.],</span>
<span class="py-output">       [0., 1.]])</span>
</pre></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">a:</span>(<code>...</code>, <code>M</code>, <code>M)</code><blockquote>
array</blockquote>
</td><td class="fieldArgDesc">Matrices for which the eigenvalues and right eigenvectors will
be computed</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><ul class="rst-simple">
<li><strong>w</strong>: (<code>...</code>, <code>M</code>) array - The eigenvalues, each repeated according to its multiplicity.
The eigenvalues are not necessarily ordered. The resulting
array will be of complex type, unless the imaginary part is
zero in which case it will be cast to a real type. When <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>
is real the resulting eigenvalues will be real (0 imaginary
part) or occur in conjugate pairs</li>
<li><strong>v</strong>: (<code>...</code>, <code>M</code>, <code>M</code>) array - The normalized (unit "length") eigenvectors, such that the
column <tt class="rst-docutils literal"><span class="pre">v[:,i]</span></tt> is the eigenvector corresponding to the
eigenvalue <tt class="rst-docutils literal">w[i]</tt>.</li>
</ul>
</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Raises</td></tr><tr><td class="fieldArgContainer"><code><a href="numpy.linalg.linalg.LinAlgError.html" class="internal-link" title="numpy.linalg.linalg.LinAlgError">LinAlgError</a></code></td><td>If the eigenvalue computation does not converge.</td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.eigh">
    
  </a>
  <a name="eigh">
    
  </a>
  <div class="functionHeader">
    @<a href="#array_function_dispatch" class="internal-link" title="numpy.linalg.linalg.array_function_dispatch">array_function_dispatch</a>(<wbr></wbr><a href="#_eigvalsh_dispatcher" class="internal-link" title="numpy.linalg.linalg._eigvalsh_dispatcher">_eigvalsh_dispatcher</a>)<br />
    <span class="py-keyword">def</span> <span class="py-defname">eigh</span>(a, UPLO=<span class="rst-variable-quote">'</span><span class="rst-variable-string">L</span><span class="rst-variable-quote">'</span>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L1317">
      
      (source)
    </a>
    <a class="headerLink" href="#eigh" title="numpy.linalg.linalg.eigh">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Return the eigenvalues and eigenvectors of a complex Hermitian
(conjugate symmetric) or a real symmetric matrix.</p>
<p>Returns two objects, a 1-D array containing the eigenvalues of <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>, and
a 2-D square array or matrix (depending on the input type) of the
corresponding eigenvectors (in columns).</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<dl class="rst-last rst-docutils">
<dt><code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#eigvalsh" class="intersphinx-link">eigvalsh</a></code></dt>
<dd>eigenvalues of real symmetric or complex Hermitian (conjugate symmetric) arrays.</dd>
<dt><code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#eig" class="intersphinx-link">eig</a></code></dt>
<dd>eigenvalues and right eigenvectors for non-symmetric arrays.</dd>
<dt><code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#eigvals" class="intersphinx-link">eigvals</a></code></dt>
<dd>eigenvalues of non-symmetric arrays.</dd>
<dt><code>scipy.linalg.eigh</code></dt>
<dd>Similar function in SciPy (but also solves the generalized eigenvalue problem).</dd>
</dl>
</div>
<div class="rst-admonition rst-admonition-notes">
<p class="rst-first rst-admonition-title">Notes</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.8.0.</span></div>
<p>Broadcasting rules apply, see the <code><a href="numpy.linalg.html" class="internal-link">numpy.linalg</a></code> documentation for
details.</p>
<p>The eigenvalues/eigenvectors are computed using LAPACK routines <tt class="rst-docutils literal">_syevd</tt>,
<tt class="rst-docutils literal">_heevd</tt>.</p>
<p class="rst-last">The eigenvalues of real symmetric or complex Hermitian matrices are
always real. <a class="rst-footnote-reference" href="#rst-footnote-1" id="rst-footnote-reference-1">[1]</a> The array <code>v</code> of (column) eigenvectors is unitary
and <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>, <code>w</code>, and <code>v</code> satisfy the equations
<tt class="rst-docutils literal">dot(a, <span class="pre">v[:,</span> i]) = w[i] * <span class="pre">v[:,</span> i]</tt>.</p>
</div>
<div class="rst-admonition rst-admonition-references">
<p class="rst-first rst-admonition-title">References</p>
<table class="rst-last rst-docutils footnote" frame="void" id="rst-footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="rst-label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>G. Strang, <em>Linear Algebra and Its Applications</em>, 2nd Ed., Orlando,
FL, Academic Press, Inc., 1980, pg. 222.</td></tr>
</tbody>
</table>
</div>
<div class="rst-admonition rst-admonition-examples">
<p class="rst-first rst-admonition-title">Examples</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> numpy <span class="py-keyword">import</span> linalg <span class="py-keyword">as</span> LA
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[1, -2j], [2j, 5]])
<span class="py-prompt">&gt;&gt;&gt; </span>a
<span class="py-output">array([[ 1.+0.j, -0.-2.j],</span>
<span class="py-output">       [ 0.+2.j,  5.+0.j]])</span>
<span class="py-prompt">&gt;&gt;&gt; </span>w, v = LA.eigh(a)
<span class="py-prompt">&gt;&gt;&gt; </span>w; v
<span class="py-output">array([0.17157288, 5.82842712])</span>
<span class="py-output">array([[-0.92387953+0.j        , -0.38268343+0.j        ], # may vary</span>
<span class="py-output">       [ 0.        +0.38268343j,  0.        -0.92387953j]])</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.dot(a, v[:, 0]) - w[0] * v[:, 0] <span class="py-comment"># verify 1st e-val/vec pair</span>
<span class="py-output">array([5.55111512e-17+0.0000000e+00j, 0.00000000e+00+1.2490009e-16j])</span>
<span class="py-prompt">&gt;&gt;&gt; </span>np.dot(a, v[:, 1]) - w[1] * v[:, 1] <span class="py-comment"># verify 2nd e-val/vec pair</span>
<span class="py-output">array([0.+0.j, 0.+0.j])</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>A = np.matrix(a) <span class="py-comment"># what happens if input is a matrix object</span>
<span class="py-prompt">&gt;&gt;&gt; </span>A
<span class="py-output">matrix([[ 1.+0.j, -0.-2.j],</span>
<span class="py-output">        [ 0.+2.j,  5.+0.j]])</span>
<span class="py-prompt">&gt;&gt;&gt; </span>w, v = LA.eigh(A)
<span class="py-prompt">&gt;&gt;&gt; </span>w; v
<span class="py-output">array([0.17157288, 5.82842712])</span>
<span class="py-output">matrix([[-0.92387953+0.j        , -0.38268343+0.j        ], # may vary</span>
<span class="py-output">        [ 0.        +0.38268343j,  0.        -0.92387953j]])</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># demonstrate the treatment of the imaginary part of the diagonal</span>
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])
<span class="py-prompt">&gt;&gt;&gt; </span>a
<span class="py-output">array([[5.+2.j, 9.-2.j],</span>
<span class="py-output">       [0.+2.j, 2.-1.j]])</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># with UPLO='L' this is numerically equivalent to using LA.eig() with:</span>
<span class="py-prompt">&gt;&gt;&gt; </span>b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])
<span class="py-prompt">&gt;&gt;&gt; </span>b
<span class="py-output">array([[5.+0.j, 0.-2.j],</span>
<span class="py-output">       [0.+2.j, 2.+0.j]])</span>
<span class="py-prompt">&gt;&gt;&gt; </span>wa, va = LA.eigh(a)
<span class="py-prompt">&gt;&gt;&gt; </span>wb, vb = LA.eig(b)
<span class="py-prompt">&gt;&gt;&gt; </span>wa; wb
<span class="py-output">array([1., 6.])</span>
<span class="py-output">array([6.+0.j, 1.+0.j])</span>
<span class="py-prompt">&gt;&gt;&gt; </span>va; vb
<span class="py-output">array([[-0.4472136 +0.j        , -0.89442719+0.j        ], # may vary</span>
<span class="py-output">       [ 0.        +0.89442719j,  0.        -0.4472136j ]])</span>
<span class="py-output">array([[ 0.89442719+0.j       , -0.        +0.4472136j],</span>
<span class="py-output">       [-0.        +0.4472136j,  0.89442719+0.j       ]])</span>
</pre></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">a:</span>(<code>...</code>, <code>M</code>, <code>M)</code><blockquote>
array</blockquote>
</td><td class="fieldArgDesc">Hermitian or real symmetric matrices whose eigenvalues and
eigenvectors are to be computed.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">UPLO:</span><span class="literal">{'L', 'U'}</span>, <em>optional</em></td><td class="fieldArgDesc">Specifies whether the calculation is done with the lower triangular
part of <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> ('L', default) or the upper triangular part ('U').
Irrespective of this value only the real parts of the diagonal will
be considered in the computation to preserve the notion of a Hermitian
matrix. It therefore follows that the imaginary part of the diagonal
will always be treated as zero.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><ul class="rst-simple">
<li><strong>w</strong>: (<code>...</code>, <code>M</code>) ndarray - The eigenvalues in ascending order, each repeated according to
its multiplicity.</li>
<li><strong>v</strong>: <tt class="rst-docutils literal"><span class="pre">{(...,</span> M, M) ndarray, <span class="pre">(...,</span> M, M) matrix}</tt> - The column <tt class="rst-docutils literal"><span class="pre">v[:,</span> i]</tt> is the normalized eigenvector corresponding
to the eigenvalue <tt class="rst-docutils literal">w[i]</tt>.  Will return a matrix object if <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> is
a matrix object.</li>
</ul>
</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Raises</td></tr><tr><td class="fieldArgContainer"><code><a href="numpy.linalg.linalg.LinAlgError.html" class="internal-link" title="numpy.linalg.linalg.LinAlgError">LinAlgError</a></code></td><td>If the eigenvalue computation does not converge.</td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.eigvals">
    
  </a>
  <a name="eigvals">
    
  </a>
  <div class="functionHeader">
    @<a href="#array_function_dispatch" class="internal-link" title="numpy.linalg.linalg.array_function_dispatch">array_function_dispatch</a>(<wbr></wbr><a href="#_unary_dispatcher" class="internal-link" title="numpy.linalg.linalg._unary_dispatcher">_unary_dispatcher</a>)<br />
    <span class="py-keyword">def</span> <span class="py-defname">eigvals</span>(a):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L969">
      
      (source)
    </a>
    <a class="headerLink" href="#eigvals" title="numpy.linalg.linalg.eigvals">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Compute the eigenvalues of a general matrix.</p>
<p>Main difference between <code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#eigvals" class="intersphinx-link">eigvals</a></code> and <code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#eig" class="intersphinx-link">eig</a></code>: the eigenvectors aren't
returned.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<dl class="rst-last rst-docutils">
<dt><code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#eig" class="intersphinx-link">eig</a></code></dt>
<dd>eigenvalues and right eigenvectors of general arrays</dd>
<dt><code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#eigvalsh" class="intersphinx-link">eigvalsh</a></code></dt>
<dd>eigenvalues of real symmetric or complex Hermitian (conjugate symmetric) arrays.</dd>
<dt><code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#eigh" class="intersphinx-link">eigh</a></code></dt>
<dd>eigenvalues and eigenvectors of real symmetric or complex Hermitian (conjugate symmetric) arrays.</dd>
<dt><code>scipy.linalg.eigvals</code></dt>
<dd>Similar function in SciPy.</dd>
</dl>
</div>
<div class="rst-admonition rst-admonition-notes">
<p class="rst-first rst-admonition-title">Notes</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.8.0.</span></div>
<p>Broadcasting rules apply, see the <code><a href="numpy.linalg.html" class="internal-link">numpy.linalg</a></code> documentation for
details.</p>
<p class="rst-last">This is implemented using the <tt class="rst-docutils literal">_geev</tt> LAPACK routines which compute
the eigenvalues and eigenvectors of general square arrays.</p>
</div>
<div class="rst-admonition rst-admonition-examples">
<p class="rst-first rst-admonition-title">Examples</p>
<p>Illustration, using the fact that the eigenvalues of a diagonal matrix
are its diagonal elements, that multiplying a matrix on the left
by an orthogonal matrix, <code>Q</code>, and on the right by <code>Q.T</code> (the transpose
of <code>Q</code>), preserves the eigenvalues of the "middle" matrix.  In other words,
if <code>Q</code> is orthogonal, then <tt class="rst-docutils literal">Q * A * Q.T</tt> has the same eigenvalues as
<tt class="rst-docutils literal">A</tt>:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> numpy <span class="py-keyword">import</span> linalg <span class="py-keyword">as</span> LA
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.random.random()
<span class="py-prompt">&gt;&gt;&gt; </span>Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
<span class="py-output">(1.0, 1.0, 0.0)</span>
</pre><p>Now multiply a diagonal matrix by <tt class="rst-docutils literal">Q</tt> on one side and by <tt class="rst-docutils literal">Q.T</tt> on the other:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>D = np.diag((-1,1))
<span class="py-prompt">&gt;&gt;&gt; </span>LA.eigvals(D)
<span class="py-output">array([-1.,  1.])</span>
<span class="py-prompt">&gt;&gt;&gt; </span>A = np.dot(Q, D)
<span class="py-prompt">&gt;&gt;&gt; </span>A = np.dot(A, Q.T)
<span class="py-prompt">&gt;&gt;&gt; </span>LA.eigvals(A)
<span class="py-output">array([ 1., -1.]) # random</span>
</pre></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">a:</span>(<code>...</code>, <code>M</code>, <code>M)</code><blockquote>
array_like</blockquote>
</td><td class="fieldArgDesc">A complex- or real-valued matrix whose eigenvalues will be computed.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">(<code>...</code>, <code>M</code>, )<blockquote>
ndarray</blockquote>
</td><td class="fieldArgDesc"><strong>w</strong> - The eigenvalues, each repeated according to its multiplicity.
They are not necessarily ordered, nor are they necessarily
real for real matrices.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Raises</td></tr><tr><td class="fieldArgContainer"><code><a href="numpy.linalg.linalg.LinAlgError.html" class="internal-link" title="numpy.linalg.linalg.LinAlgError">LinAlgError</a></code></td><td>If the eigenvalue computation does not converge.</td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.eigvalsh">
    
  </a>
  <a name="eigvalsh">
    
  </a>
  <div class="functionHeader">
    @<a href="#array_function_dispatch" class="internal-link" title="numpy.linalg.linalg.array_function_dispatch">array_function_dispatch</a>(<wbr></wbr><a href="#_eigvalsh_dispatcher" class="internal-link" title="numpy.linalg.linalg._eigvalsh_dispatcher">_eigvalsh_dispatcher</a>)<br />
    <span class="py-keyword">def</span> <span class="py-defname">eigvalsh</span>(a, UPLO=<span class="rst-variable-quote">'</span><span class="rst-variable-string">L</span><span class="rst-variable-quote">'</span>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L1065">
      
      (source)
    </a>
    <a class="headerLink" href="#eigvalsh" title="numpy.linalg.linalg.eigvalsh">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Compute the eigenvalues of a complex Hermitian or real symmetric matrix.</p>
<p>Main difference from eigh: the eigenvectors are not computed.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<dl class="rst-last rst-docutils">
<dt><code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#eigh" class="intersphinx-link">eigh</a></code></dt>
<dd>eigenvalues and eigenvectors of real symmetric or complex Hermitian (conjugate symmetric) arrays.</dd>
<dt><code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#eigvals" class="intersphinx-link">eigvals</a></code></dt>
<dd>eigenvalues of general real or complex arrays.</dd>
<dt><code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#eig" class="intersphinx-link">eig</a></code></dt>
<dd>eigenvalues and right eigenvectors of general real or complex arrays.</dd>
<dt><code>scipy.linalg.eigvalsh</code></dt>
<dd>Similar function in SciPy.</dd>
</dl>
</div>
<div class="rst-admonition rst-admonition-notes">
<p class="rst-first rst-admonition-title">Notes</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.8.0.</span></div>
<p>Broadcasting rules apply, see the <code><a href="numpy.linalg.html" class="internal-link">numpy.linalg</a></code> documentation for
details.</p>
<p class="rst-last">The eigenvalues are computed using LAPACK routines <tt class="rst-docutils literal">_syevd</tt>, <tt class="rst-docutils literal">_heevd</tt>.</p>
</div>
<div class="rst-admonition rst-admonition-examples">
<p class="rst-first rst-admonition-title">Examples</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> numpy <span class="py-keyword">import</span> linalg <span class="py-keyword">as</span> LA
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[1, -2j], [2j, 5]])
<span class="py-prompt">&gt;&gt;&gt; </span>LA.eigvalsh(a)
<span class="py-output">array([ 0.17157288,  5.82842712]) # may vary</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># demonstrate the treatment of the imaginary part of the diagonal</span>
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])
<span class="py-prompt">&gt;&gt;&gt; </span>a
<span class="py-output">array([[5.+2.j, 9.-2.j],</span>
<span class="py-output">       [0.+2.j, 2.-1.j]])</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># with UPLO='L' this is numerically equivalent to using LA.eigvals()</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># with:</span>
<span class="py-prompt">&gt;&gt;&gt; </span>b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])
<span class="py-prompt">&gt;&gt;&gt; </span>b
<span class="py-output">array([[5.+0.j, 0.-2.j],</span>
<span class="py-output">       [0.+2.j, 2.+0.j]])</span>
<span class="py-prompt">&gt;&gt;&gt; </span>wa = LA.eigvalsh(a)
<span class="py-prompt">&gt;&gt;&gt; </span>wb = LA.eigvals(b)
<span class="py-prompt">&gt;&gt;&gt; </span>wa; wb
<span class="py-output">array([1., 6.])</span>
<span class="py-output">array([6.+0.j, 1.+0.j])</span>
</pre></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">a:</span>(<code>...</code>, <code>M</code>, <code>M)</code><blockquote>
array_like</blockquote>
</td><td class="fieldArgDesc">A complex- or real-valued matrix whose eigenvalues are to be
computed.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">UPLO:</span><span class="literal">{'L', 'U'}</span>, <em>optional</em></td><td class="fieldArgDesc">Specifies whether the calculation is done with the lower triangular
part of <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> ('L', default) or the upper triangular part ('U').
Irrespective of this value only the real parts of the diagonal will
be considered in the computation to preserve the notion of a Hermitian
matrix. It therefore follows that the imaginary part of the diagonal
will always be treated as zero.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">(<code>...</code>, <code>M</code>, )<blockquote>
ndarray</blockquote>
</td><td class="fieldArgDesc"><strong>w</strong> - The eigenvalues in ascending order, each repeated according to
its multiplicity.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Raises</td></tr><tr><td class="fieldArgContainer"><code><a href="numpy.linalg.linalg.LinAlgError.html" class="internal-link" title="numpy.linalg.linalg.LinAlgError">LinAlgError</a></code></td><td>If the eigenvalue computation does not converge.</td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.get_linalg_error_extobj">
    
  </a>
  <a name="get_linalg_error_extobj">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">get_linalg_error_extobj</span>(callback):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L107">
      
      (source)
    </a>
    <a class="headerLink" href="#get_linalg_error_extobj" title="numpy.linalg.linalg.get_linalg_error_extobj">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.inv">
    
  </a>
  <a name="inv">
    
  </a>
  <div class="functionHeader">
    @<a href="#array_function_dispatch" class="internal-link" title="numpy.linalg.linalg.array_function_dispatch">array_function_dispatch</a>(<wbr></wbr><a href="#_unary_dispatcher" class="internal-link" title="numpy.linalg.linalg._unary_dispatcher">_unary_dispatcher</a>)<br />
    <span class="py-keyword">def</span> <span class="py-defname">inv</span>(a):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L469">
      
      (source)
    </a>
    <a class="headerLink" href="#inv" title="numpy.linalg.linalg.inv">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Compute the (multiplicative) inverse of a matrix.</p>
<p>Given a square matrix <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>, return the matrix <code>ainv</code> satisfying
<tt class="rst-docutils literal">dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])</tt>.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<dl class="rst-last rst-docutils">
<dt><code>scipy.linalg.inv</code></dt>
<dd>Similar function in SciPy.</dd>
</dl>
</div>
<div class="rst-admonition rst-admonition-notes">
<p class="rst-first rst-admonition-title">Notes</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.8.0.</span></div>
<p class="rst-last">Broadcasting rules apply, see the <code><a href="numpy.linalg.html" class="internal-link">numpy.linalg</a></code> documentation for
details.</p>
</div>
<div class="rst-admonition rst-admonition-examples">
<p class="rst-first rst-admonition-title">Examples</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> numpy.linalg <span class="py-keyword">import</span> inv
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[1., 2.], [3., 4.]])
<span class="py-prompt">&gt;&gt;&gt; </span>ainv = inv(a)
<span class="py-prompt">&gt;&gt;&gt; </span>np.allclose(np.dot(a, ainv), np.eye(2))
<span class="py-output">True</span>
<span class="py-prompt">&gt;&gt;&gt; </span>np.allclose(np.dot(ainv, a), np.eye(2))
<span class="py-output">True</span>
</pre><p>If a is a matrix object, then the return value is a matrix as well:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>ainv = inv(np.matrix(a))
<span class="py-prompt">&gt;&gt;&gt; </span>ainv
<span class="py-output">matrix([[-2. ,  1. ],</span>
<span class="py-output">        [ 1.5, -0.5]])</span>
</pre><p>Inverses of several matrices can be computed at once:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])
<span class="py-prompt">&gt;&gt;&gt; </span>inv(a)
<span class="py-output">array([[[-2.  ,  1.  ],</span>
<span class="py-output">        [ 1.5 , -0.5 ]],</span>
<span class="py-output">       [[-1.25,  0.75],</span>
<span class="py-output">        [ 0.75, -0.25]]])</span>
</pre></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">a:</span>(<code>...</code>, <code>M</code>, <code>M)</code><blockquote>
array_like</blockquote>
</td><td class="fieldArgDesc">Matrix to be inverted.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">(<code>...</code>, <code>M</code>, <code>M)</code><blockquote>
ndarray</blockquote>
 or <code><a href="numpy.matrixlib.defmatrix.matrix.html" class="internal-link" title="numpy.matrixlib.defmatrix.matrix">matrix</a></code></td><td class="fieldArgDesc"><strong>ainv</strong> - (Multiplicative) inverse of the matrix <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Raises</td></tr><tr><td class="fieldArgContainer"><code><a href="numpy.linalg.linalg.LinAlgError.html" class="internal-link" title="numpy.linalg.linalg.LinAlgError">LinAlgError</a></code></td><td>If <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> is not square or inversion fails.</td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.isComplexType">
    
  </a>
  <a name="isComplexType">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">isComplexType</span>(t):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L117">
      
      (source)
    </a>
    <a class="headerLink" href="#isComplexType" title="numpy.linalg.linalg.isComplexType">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.lstsq">
    
  </a>
  <a name="lstsq">
    
  </a>
  <div class="functionHeader">
    @<a href="#array_function_dispatch" class="internal-link" title="numpy.linalg.linalg.array_function_dispatch">array_function_dispatch</a>(<wbr></wbr><a href="#_lstsq_dispatcher" class="internal-link" title="numpy.linalg.linalg._lstsq_dispatcher">_lstsq_dispatcher</a>)<br />
    <span class="py-keyword">def</span> <span class="py-defname">lstsq</span>(a, b, rcond=<span class="rst-variable-quote">'</span><span class="rst-variable-string">warn</span><span class="rst-variable-quote">'</span>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L2150">
      
      (source)
    </a>
    <a class="headerLink" href="#lstsq" title="numpy.linalg.linalg.lstsq">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Return the least-squares solution to a linear matrix equation.</p>
<p>Computes the vector <code>x</code> that approximately solves the equation
<tt class="rst-docutils literal">a @ x = b</tt>. The equation may be under-, well-, or over-determined
(i.e., the number of linearly independent rows of <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> can be less than,
equal to, or greater than its number of linearly independent columns).
If <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> is square and of full rank, then <code>x</code> (but for round-off error)
is the "exact" solution of the equation. Else, <code>x</code> minimizes the
Euclidean 2-norm <span class="rst-formula">||<i>b</i> − <i>ax</i>||</span>. If there are multiple minimizing
solutions, the one with the smallest 2-norm <span class="rst-formula">||<i>x</i>||</span> is returned.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<dl class="rst-last rst-docutils">
<dt><code>scipy.linalg.lstsq</code></dt>
<dd>Similar function in SciPy.</dd>
</dl>
</div>
<div class="rst-admonition rst-admonition-notes">
<p class="rst-first rst-admonition-title">Notes</p>
<p class="rst-last">If <code>b</code> is a matrix, then all array results are returned as matrices.</p>
</div>
<div class="rst-admonition rst-admonition-examples">
<p class="rst-first rst-admonition-title">Examples</p>
<p>Fit a line, <tt class="rst-docutils literal">y = mx + c</tt>, through some noisy data-points:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.array([0, 1, 2, 3])
<span class="py-prompt">&gt;&gt;&gt; </span>y = np.array([-1, 0.2, 0.9, 2.1])</pre><p>By examining the coefficients, we see that the line should have a
gradient of roughly 1 and cut the y-axis at, more or less, -1.</p>
<p>We can rewrite the line equation as <tt class="rst-docutils literal">y = Ap</tt>, where <tt class="rst-docutils literal">A = [[x 1]]</tt>
and <tt class="rst-docutils literal">p = [[m], [c]]</tt>.  Now use <code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#lstsq" class="intersphinx-link">lstsq</a></code> to solve for <code><a href="numpy.array_api.tests.test_validation.html#p" class="internal-link" title="numpy.array_api.tests.test_validation.p">p</a></code>:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>A = np.vstack([x, np.ones(<span class="py-builtin">len</span>(x))]).T
<span class="py-prompt">&gt;&gt;&gt; </span>A
<span class="py-output">array([[ 0.,  1.],</span>
<span class="py-output">       [ 1.,  1.],</span>
<span class="py-output">       [ 2.,  1.],</span>
<span class="py-output">       [ 3.,  1.]])</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>m, c = np.linalg.lstsq(A, y, rcond=<span class="py-builtin">None</span>)[0]
<span class="py-prompt">&gt;&gt;&gt; </span>m, c
<span class="py-output">(1.0 -0.95) # may vary</span>
</pre><p>Plot the data along with the fitted line:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">import</span> matplotlib.pyplot <span class="py-keyword">as</span> plt
<span class="py-prompt">&gt;&gt;&gt; </span>_ = plt.plot(x, y, <span class="py-string">'o'</span>, label=<span class="py-string">'Original data'</span>, markersize=10)
<span class="py-prompt">&gt;&gt;&gt; </span>_ = plt.plot(x, m*x + c, <span class="py-string">'r'</span>, label=<span class="py-string">'Fitted line'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>_ = plt.legend()
<span class="py-prompt">&gt;&gt;&gt; </span>plt.show()</pre></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">a:</span>(<code>M</code>, <code>N)</code><blockquote>
array_like</blockquote>
</td><td class="fieldArgDesc">"Coefficient" matrix.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">b:</span><span class="literal">{(M, ), (M, K)} array_like</span></td><td class="fieldArgDesc">Ordinate or "dependent variable" values. If <code>b</code> is two-dimensional,
the least-squares solution is calculated for each of the <code>K</code> columns
of <code>b</code>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">rcond:</span><code><a href="https://docs.python.org/3/library/functions.html#float" class="intersphinx-link">float</a></code>, <em>optional</em></td><td class="fieldArgDesc"><p>Cut-off ratio for small singular values of <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>.
For the purposes of rank determination, singular values are treated
as zero if they are smaller than <code>rcond</code> times the largest singular
value of <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.14.0: </span><span>If not set, a FutureWarning is given. The previous default
of <tt class="rst-docutils literal"><span class="pre">-1</span></tt> will use the machine precision as <code>rcond</code> parameter,
the new default will use the machine precision times <code>max(M, N)</code>.
To silence the warning and use the new default, use <tt class="rst-docutils literal">rcond=None</tt>,
to keep using the old behavior, use <tt class="rst-docutils literal"><span class="pre">rcond=-1</span></tt>.</span></div>
</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><ul class="rst-simple">
<li><strong>x</strong>: <tt class="rst-docutils literal">{(N, ), (N, K)} ndarray</tt> - Least-squares solution. If <code>b</code> is two-dimensional,
the solutions are in the <code>K</code> columns of <code>x</code>.</li>
<li><strong>residuals</strong>: <tt class="rst-docutils literal">{(1, ), (K, ), (0, )} ndarray</tt> - Sums of squared residuals: Squared Euclidean 2-norm for each column in
<tt class="rst-docutils literal">b - a @ x</tt>.
If the rank of <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> is &lt; N or M &lt;= N, this is an empty array.
If <code>b</code> is 1-dimensional, this is a (1,) shape array.
Otherwise the shape is (K,).</li>
<li><strong>rank</strong>: <code><a href="https://docs.python.org/3/library/functions.html#int" class="intersphinx-link">int</a></code> - Rank of matrix <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>.</li>
<li><strong>s</strong>: (<code><a href="https://docs.python.org/3/library/functions.html#min" class="intersphinx-link">min</a></code>(<code>M</code>, <code>N</code>), ) ndarray - Singular values of <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>.</li>
</ul>
</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Raises</td></tr><tr><td class="fieldArgContainer"><code><a href="numpy.linalg.linalg.LinAlgError.html" class="internal-link" title="numpy.linalg.linalg.LinAlgError">LinAlgError</a></code></td><td>If computation does not converge.</td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.matrix_power">
    
  </a>
  <a name="matrix_power">
    
  </a>
  <div class="functionHeader">
    @<a href="#array_function_dispatch" class="internal-link" title="numpy.linalg.linalg.array_function_dispatch">array_function_dispatch</a>(<wbr></wbr><a href="#_matrix_power_dispatcher" class="internal-link" title="numpy.linalg.linalg._matrix_power_dispatcher">_matrix_power_dispatcher</a>)<br />
    <span class="py-keyword">def</span> <span class="py-defname">matrix_power</span>(a, n):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L546">
      
      (source)
    </a>
    <a class="headerLink" href="#matrix_power" title="numpy.linalg.linalg.matrix_power">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Raise a square matrix to the (integer) power <code>n</code>.</p>
<p>For positive integers <code>n</code>, the power is computed by repeated matrix
squarings and matrix multiplications. If <tt class="rst-docutils literal">n == 0</tt>, the identity matrix
of the same shape as M is returned. If <tt class="rst-docutils literal">n &lt; 0</tt>, the inverse
is computed and then raised to the <tt class="rst-docutils literal">abs(n)</tt>.</p>
<div class="rst-admonition note">
<p class="rst-first rst-admonition-title">Note</p>
<p class="rst-last">Stacks of object matrices are not currently supported.</p>
</div>
<div class="rst-admonition rst-admonition-examples">
<p class="rst-first rst-admonition-title">Examples</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> numpy.linalg <span class="py-keyword">import</span> matrix_power
<span class="py-prompt">&gt;&gt;&gt; </span>i = np.array([[0, 1], [-1, 0]]) <span class="py-comment"># matrix equiv. of the imaginary unit</span>
<span class="py-prompt">&gt;&gt;&gt; </span>matrix_power(i, 3) <span class="py-comment"># should = -i</span>
<span class="py-output">array([[ 0, -1],</span>
<span class="py-output">       [ 1,  0]])</span>
<span class="py-prompt">&gt;&gt;&gt; </span>matrix_power(i, 0)
<span class="py-output">array([[1, 0],</span>
<span class="py-output">       [0, 1]])</span>
<span class="py-prompt">&gt;&gt;&gt; </span>matrix_power(i, -3) <span class="py-comment"># should = 1/(-i) = i, but w/ f.p. elements</span>
<span class="py-output">array([[ 0.,  1.],</span>
<span class="py-output">       [-1.,  0.]])</span>
</pre><p>Somewhat more sophisticated example</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>q = np.zeros((4, 4))
<span class="py-prompt">&gt;&gt;&gt; </span>q[0:2, 0:2] = -i
<span class="py-prompt">&gt;&gt;&gt; </span>q[2:4, 2:4] = i
<span class="py-prompt">&gt;&gt;&gt; </span>q <span class="py-comment"># one of the three quaternion units not equal to 1</span>
<span class="py-output">array([[ 0., -1.,  0.,  0.],</span>
<span class="py-output">       [ 1.,  0.,  0.,  0.],</span>
<span class="py-output">       [ 0.,  0.,  0.,  1.],</span>
<span class="py-output">       [ 0.,  0., -1.,  0.]])</span>
<span class="py-prompt">&gt;&gt;&gt; </span>matrix_power(q, 2) <span class="py-comment"># = -np.eye(4)</span>
<span class="py-output">array([[-1.,  0.,  0.,  0.],</span>
<span class="py-output">       [ 0., -1.,  0.,  0.],</span>
<span class="py-output">       [ 0.,  0., -1.,  0.],</span>
<span class="py-output">       [ 0.,  0.,  0., -1.]])</span>
</pre></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">a:</span>(<code>...</code>, <code>M</code>, <code>M)</code><blockquote>
array_like</blockquote>
</td><td class="fieldArgDesc">Matrix to be "powered".</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">n:</span><code><a href="https://docs.python.org/3/library/functions.html#int" class="intersphinx-link">int</a></code></td><td class="fieldArgDesc">The exponent can be any integer or long integer, positive,
negative, or zero.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">(<code>...</code>, <code>M</code>, <code>M)</code><blockquote>
ndarray</blockquote>
 or matrix object</td><td class="fieldArgDesc"><strong>a**n</strong> - The return value is the same shape and type as <code>M</code>;
if the exponent is positive or zero then the type of the
elements is the same as those of <code>M</code>. If the exponent is
negative the elements are floating-point.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Raises</td></tr><tr><td class="fieldArgContainer"><code><a href="numpy.linalg.linalg.LinAlgError.html" class="internal-link" title="numpy.linalg.linalg.LinAlgError">LinAlgError</a></code></td><td>For matrices that are not square or that (for negative powers) cannot
be inverted numerically.</td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.matrix_rank">
    
  </a>
  <a name="matrix_rank">
    
  </a>
  <div class="functionHeader">
    @<a href="#array_function_dispatch" class="internal-link" title="numpy.linalg.linalg.array_function_dispatch">array_function_dispatch</a>(<wbr></wbr><a href="#_matrix_rank_dispatcher" class="internal-link" title="numpy.linalg.linalg._matrix_rank_dispatcher">_matrix_rank_dispatcher</a>)<br />
    <span class="py-keyword">def</span> <span class="py-defname">matrix_rank</span>(A, tol=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, hermitian=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L1786">
      
      (source)
    </a>
    <a class="headerLink" href="#matrix_rank" title="numpy.linalg.linalg.matrix_rank">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Return matrix rank of array using SVD method</p>
<p>Rank of the array is the number of singular values of the array that are
greater than <code>tol</code>.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.14: </span><span>Can now operate on stacks of matrices</span></div>
<div class="rst-admonition rst-admonition-notes">
<p class="rst-first rst-admonition-title">Notes</p>
<p>The default threshold to detect rank deficiency is a test on the magnitude
of the singular values of <code><a href="numpy.core.tests.test_scalarinherit.A.html" class="internal-link" title="numpy.core.tests.test_scalarinherit.A">A</a></code>.  By default, we identify singular values less
than <tt class="rst-docutils literal">S.max() * max(M, N) * eps</tt> as indicating rank deficiency (with
the symbols defined above). This is the algorithm MATLAB uses [1].  It also
appears in <em>Numerical recipes</em> in the discussion of SVD solutions for linear
least squares [2].</p>
<p>This default threshold is designed to detect rank deficiency accounting for
the numerical errors of the SVD computation.  Imagine that there is a column
in <code><a href="numpy.core.tests.test_scalarinherit.A.html" class="internal-link" title="numpy.core.tests.test_scalarinherit.A">A</a></code> that is an exact (in floating point) linear combination of other
columns in <code><a href="numpy.core.tests.test_scalarinherit.A.html" class="internal-link" title="numpy.core.tests.test_scalarinherit.A">A</a></code>. Computing the SVD on <code><a href="numpy.core.tests.test_scalarinherit.A.html" class="internal-link" title="numpy.core.tests.test_scalarinherit.A">A</a></code> will not produce a singular value
exactly equal to 0 in general: any difference of the smallest SVD value from
0 will be caused by numerical imprecision in the calculation of the SVD.
Our threshold for small SVD values takes this numerical imprecision into
account, and the default threshold will detect such numerical rank
deficiency.  The threshold may declare a matrix <code><a href="numpy.core.tests.test_scalarinherit.A.html" class="internal-link" title="numpy.core.tests.test_scalarinherit.A">A</a></code> rank deficient even if
the linear combination of some columns of <code><a href="numpy.core.tests.test_scalarinherit.A.html" class="internal-link" title="numpy.core.tests.test_scalarinherit.A">A</a></code> is not exactly equal to
another column of <code><a href="numpy.core.tests.test_scalarinherit.A.html" class="internal-link" title="numpy.core.tests.test_scalarinherit.A">A</a></code> but only numerically very close to another column of
<code><a href="numpy.core.tests.test_scalarinherit.A.html" class="internal-link" title="numpy.core.tests.test_scalarinherit.A">A</a></code>.</p>
<p>We chose our default threshold because it is in wide use.  Other thresholds
are possible.  For example, elsewhere in the 2007 edition of <em>Numerical
recipes</em> there is an alternative threshold of <tt class="rst-docutils literal">S.max() *
<span class="pre">np.finfo(A.dtype).eps</span> / 2. * np.sqrt(m + n + 1.)</tt>. The authors describe
this threshold as being based on "expected roundoff error" (p 71).</p>
<p class="rst-last">The thresholds above deal with floating point roundoff error in the
calculation of the SVD.  However, you may have more information about the
sources of error in <code><a href="numpy.core.tests.test_scalarinherit.A.html" class="internal-link" title="numpy.core.tests.test_scalarinherit.A">A</a></code> that would make you consider other tolerance values
to detect <em>effective</em> rank deficiency.  The most useful measure of the
tolerance depends on the operations you intend to use on your matrix.  For
example, if your data come from uncertain measurements with uncertainties
greater than floating point epsilon, choosing a tolerance near that
uncertainty may be preferable.  The tolerance may be absolute if the
uncertainties are absolute rather than relative.</p>
</div>
<div class="rst-admonition rst-admonition-references">
<p class="rst-first rst-admonition-title">References</p>
<table class="rst-docutils footnote" frame="void" id="rst-footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="rst-label">[1]</td><td>MATLAB reference documentation, "Rank"
<a class="rst-reference external" href="https://www.mathworks.com/help/techdoc/ref/rank.html" target="_top">https://www.mathworks.com/help/techdoc/ref/rank.html</a></td></tr>
</tbody>
</table>
<table class="rst-last rst-docutils footnote" frame="void" id="rst-footnote-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="rst-label">[2]</td><td>W. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery,
"Numerical Recipes (3rd edition)", Cambridge University Press, 2007,
page 795.</td></tr>
</tbody>
</table>
</div>
<div class="rst-admonition rst-admonition-examples">
<p class="rst-first rst-admonition-title">Examples</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> numpy.linalg <span class="py-keyword">import</span> matrix_rank
<span class="py-prompt">&gt;&gt;&gt; </span>matrix_rank(np.eye(4)) <span class="py-comment"># Full rank matrix</span>
<span class="py-output">4</span>
<span class="py-prompt">&gt;&gt;&gt; </span>I=np.eye(4); I[-1,-1] = 0. <span class="py-comment"># rank deficient matrix</span>
<span class="py-prompt">&gt;&gt;&gt; </span>matrix_rank(I)
<span class="py-output">3</span>
<span class="py-prompt">&gt;&gt;&gt; </span>matrix_rank(np.ones((4,))) <span class="py-comment"># 1 dimension - rank 1 unless all 0</span>
<span class="py-output">1</span>
<span class="py-prompt">&gt;&gt;&gt; </span>matrix_rank(np.zeros((4,)))
<span class="py-output">0</span>
</pre></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">A:</span><span class="literal">{(M, ), (..., M, N)} array_like</span></td><td class="fieldArgDesc">Input vector or stack of matrices.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">tol:</span>(<code>...)</code><blockquote>
array_like</blockquote>
, <code><a href="https://docs.python.org/3/library/functions.html#float" class="intersphinx-link">float</a></code>, <em>optional</em></td><td class="fieldArgDesc"><p>Threshold below which SVD values are considered zero. If <code>tol</code> is
None, and <tt class="rst-docutils literal">S</tt> is an array with singular values for <code>M</code>, and
<tt class="rst-docutils literal">eps</tt> is the epsilon value for datatype of <tt class="rst-docutils literal">S</tt>, then <code>tol</code> is
set to <tt class="rst-docutils literal">S.max() * max(M, N) * eps</tt>.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.14: </span><span>Broadcasted against the stack of matrices</span></div>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">hermitian:</span><code><a href="https://docs.python.org/3/library/functions.html#bool" class="intersphinx-link">bool</a></code>, <em>optional</em></td><td class="fieldArgDesc"><p>If True, <code><a href="numpy.core.tests.test_scalarinherit.A.html" class="internal-link" title="numpy.core.tests.test_scalarinherit.A">A</a></code> is assumed to be Hermitian (symmetric if real-valued),
enabling a more efficient method for finding singular values.
Defaults to False.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.14.</span></div>
</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">(<code>...)</code><blockquote>
array_like</blockquote>
</td><td class="fieldArgDesc"><strong>rank</strong> - Rank of A.</td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.multi_dot">
    
  </a>
  <a name="multi_dot">
    
  </a>
  <div class="functionHeader">
    @<a href="#array_function_dispatch" class="internal-link" title="numpy.linalg.linalg.array_function_dispatch">array_function_dispatch</a>(<wbr></wbr><a href="#_multidot_dispatcher" class="internal-link" title="numpy.linalg.linalg._multidot_dispatcher">_multidot_dispatcher</a>)<br />
    <span class="py-keyword">def</span> <span class="py-defname">multi_dot</span>(arrays, *, out=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L2602">
      
      (source)
    </a>
    <a class="headerLink" href="#multi_dot" title="numpy.linalg.linalg.multi_dot">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Compute the dot product of two or more arrays in a single function call,
while automatically selecting the fastest evaluation order.</p>
<p><code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#multi_dot" class="intersphinx-link">multi_dot</a></code> chains <code>numpy.dot</code> and uses optimal parenthesization
of the matrices <a class="rst-footnote-reference" href="#rst-footnote-1" id="rst-footnote-reference-1">[1]</a> <a class="rst-footnote-reference" href="#rst-footnote-2" id="rst-footnote-reference-2">[2]</a>. Depending on the shapes of the matrices,
this can speed up the multiplication a lot.</p>
<p>If the first argument is 1-D it is treated as a row vector.
If the last argument is 1-D it is treated as a column vector.
The other arguments must be 2-D.</p>
<p>Think of <code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#multi_dot" class="intersphinx-link">multi_dot</a></code> as:</p>
<pre class="rst-literal-block">
def multi_dot(arrays): return functools.reduce(np.dot, arrays)
</pre>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<dl class="rst-last rst-docutils">
<dt><code>numpy.dot</code></dt>
<dd>dot multiplication with two arguments.</dd>
</dl>
</div>
<div class="rst-admonition rst-admonition-references">
<p class="rst-first rst-admonition-title">References</p>
<table class="rst-docutils footnote" frame="void" id="rst-footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="rst-label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>Cormen, "Introduction to Algorithms", Chapter 15.2, p. 370-378</td></tr>
</tbody>
</table>
<table class="rst-last rst-docutils footnote" frame="void" id="rst-footnote-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="rst-label"><a class="fn-backref" href="#footnote-reference-2">[2]</a></td><td><a class="rst-reference external" href="https://en.wikipedia.org/wiki/Matrix_chain_multiplication" target="_top">https://en.wikipedia.org/wiki/Matrix_chain_multiplication</a></td></tr>
</tbody>
</table>
</div>
<div class="rst-admonition rst-admonition-examples">
<p class="rst-first rst-admonition-title">Examples</p>
<p><code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#multi_dot" class="intersphinx-link">multi_dot</a></code> allows you to write:</p>
<pre class="rst-literal-block">
&gt;&gt;&gt; from numpy.linalg import multi_dot
&gt;&gt;&gt; # Prepare some data
&gt;&gt;&gt; A = np.random.random((10000, 100))
&gt;&gt;&gt; B = np.random.random((100, 1000))
&gt;&gt;&gt; C = np.random.random((1000, 5))
&gt;&gt;&gt; D = np.random.random((5, 333))
&gt;&gt;&gt; # the actual dot multiplication
&gt;&gt;&gt; _ = multi_dot([A, B, C, D])
</pre>
<p>instead of:</p>
<pre class="rst-last rst-literal-block">
&gt;&gt;&gt; _ = np.dot(np.dot(np.dot(A, B), C), D)
&gt;&gt;&gt; # or
&gt;&gt;&gt; _ = A.dot(B).dot(C).dot(D)
</pre>
</div>
<div class="rst-admonition rst-admonition-notes">
<p class="rst-first rst-admonition-title">Notes</p>
<p>The cost for a matrix multiplication can be calculated with the
following function:</p>
<pre class="rst-literal-block">
def cost(A, B):
    return A.shape[0] * A.shape[1] * B.shape[1]
</pre>
<p>Assume we have three matrices
<span class="rst-formula"><i>A</i><sub>10<i>x</i>100</sub>, <i>B</i><sub>100<i>x</i>5</sub>, <i>C</i><sub>5<i>x</i>50</sub></span>.</p>
<p>The costs for the two different parenthesizations are as follows:</p>
<pre class="rst-last rst-literal-block">
cost((AB)C) = 10*100*5 + 10*5*50   = 5000 + 2500   = 7500
cost(A(BC)) = 10*100*50 + 100*5*50 = 50000 + 25000 = 75000
</pre>
</div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">arrays:</span><code>sequence</code> of <code>array_like</code></td><td class="fieldArgDesc">If the first argument is 1-D it is treated as row vector.
If the last argument is 1-D it is treated as column vector.
The other arguments must be 2-D.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">out:</span><code>ndarray</code>, <em>optional</em></td><td class="fieldArgDesc"><p>Output argument. This must have the exact kind that would be returned
if it was not used. In particular, it must have the right type, must be
C-contiguous, and its dtype must be the dtype that would be returned
for <code>dot(a, b)</code>. This is a performance feature. Therefore, if these
conditions are not met, an exception is raised, instead of attempting
to be flexible.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.19.0.</span></div>
</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer"><code>ndarray</code></td><td class="fieldArgDesc"><strong>output</strong> - Returns the dot product of the supplied arrays.</td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.norm">
    
  </a>
  <a name="norm">
    
  </a>
  <div class="functionHeader">
    @<a href="#array_function_dispatch" class="internal-link" title="numpy.linalg.linalg.array_function_dispatch">array_function_dispatch</a>(<wbr></wbr><a href="#_norm_dispatcher" class="internal-link" title="numpy.linalg.linalg._norm_dispatcher">_norm_dispatcher</a>)<br />
    <span class="py-keyword">def</span> <span class="py-defname">norm</span>(x, ord=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, axis=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, keepdims=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L2342">
      
      (source)
    </a>
    <a class="headerLink" href="#norm" title="numpy.linalg.linalg.norm">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Matrix or vector norm.</p>
<p>This function is able to return one of eight different matrix norms,
or one of an infinite number of vector norms (described below), depending
on the value of the <tt class="rst-docutils literal">ord</tt> parameter.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<dl class="rst-last rst-docutils">
<dt><code>scipy.linalg.norm</code></dt>
<dd>Similar function in SciPy.</dd>
</dl>
</div>
<div class="rst-admonition rst-admonition-notes">
<p class="rst-first rst-admonition-title">Notes</p>
<p>For values of <tt class="rst-docutils literal">ord &lt; 1</tt>, the result is, strictly speaking, not a
mathematical 'norm', but it may still be useful for various numerical
purposes.</p>
<p>The following norms can be calculated:</p>
<table border="1" class="rst-docutils">
<colgroup>
<col width="8%" />
<col width="47%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr><th class="rst-head">ord</th>
<th class="rst-head">norm for matrices</th>
<th class="rst-head">norm for vectors</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>None</td>
<td>Frobenius norm</td>
<td>2-norm</td>
</tr>
<tr><td>'fro'</td>
<td>Frobenius norm</td>
<td>--</td>
</tr>
<tr><td>'nuc'</td>
<td>nuclear norm</td>
<td>--</td>
</tr>
<tr><td>inf</td>
<td>max(sum(abs(x), axis=1))</td>
<td>max(abs(x))</td>
</tr>
<tr><td>-inf</td>
<td>min(sum(abs(x), axis=1))</td>
<td>min(abs(x))</td>
</tr>
<tr><td>0</td>
<td>--</td>
<td>sum(x != 0)</td>
</tr>
<tr><td>1</td>
<td>max(sum(abs(x), axis=0))</td>
<td>as below</td>
</tr>
<tr><td>-1</td>
<td>min(sum(abs(x), axis=0))</td>
<td>as below</td>
</tr>
<tr><td>2</td>
<td>2-norm (largest sing. value)</td>
<td>as below</td>
</tr>
<tr><td>-2</td>
<td>smallest singular value</td>
<td>as below</td>
</tr>
<tr><td>other</td>
<td>--</td>
<td>sum(abs(x)**ord)**(1./ord)</td>
</tr>
</tbody>
</table>
<p>The Frobenius norm is given by <a class="rst-footnote-reference" href="#rst-footnote-1" id="rst-footnote-reference-1">[1]</a>:</p>
<blockquote>
<span class="rst-formula">||<i>A</i>||<sub><i>F</i></sub> = [<span class="limits"><span class="limit"><span class="bigoperator">∑</span></span></span><sub><i>i</i>, <i>j</i></sub><i>abs</i>(<i>a</i><sub><i>i</i>, <i>j</i></sub>)<sup>2</sup>]<sup>1 ⁄ 2</sup></span></blockquote>
<p>The nuclear norm is the sum of the singular values.</p>
<p class="rst-last">Both the Frobenius and nuclear norm orders are only defined for
matrices and raise a ValueError when <tt class="rst-docutils literal">x.ndim != 2</tt>.</p>
</div>
<div class="rst-admonition rst-admonition-references">
<p class="rst-first rst-admonition-title">References</p>
<table class="rst-last rst-docutils footnote" frame="void" id="rst-footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="rst-label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>G. H. Golub and C. F. Van Loan, <em>Matrix Computations</em>,
Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</td></tr>
</tbody>
</table>
</div>
<div class="rst-admonition rst-admonition-examples">
<p class="rst-first rst-admonition-title">Examples</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> numpy <span class="py-keyword">import</span> linalg <span class="py-keyword">as</span> LA
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.arange(9) - 4
<span class="py-prompt">&gt;&gt;&gt; </span>a
<span class="py-output">array([-4, -3, -2, ...,  2,  3,  4])</span>
<span class="py-prompt">&gt;&gt;&gt; </span>b = a.reshape((3, 3))
<span class="py-prompt">&gt;&gt;&gt; </span>b
<span class="py-output">array([[-4, -3, -2],</span>
<span class="py-output">       [-1,  0,  1],</span>
<span class="py-output">       [ 2,  3,  4]])</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(a)
<span class="py-output">7.745966692414834</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(b)
<span class="py-output">7.745966692414834</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(b, <span class="py-string">'fro'</span>)
<span class="py-output">7.745966692414834</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(a, np.inf)
<span class="py-output">4.0</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(b, np.inf)
<span class="py-output">9.0</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(a, -np.inf)
<span class="py-output">0.0</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(b, -np.inf)
<span class="py-output">2.0</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(a, 1)
<span class="py-output">20.0</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(b, 1)
<span class="py-output">7.0</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(a, -1)
<span class="py-output">-4.6566128774142013e-010</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(b, -1)
<span class="py-output">6.0</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(a, 2)
<span class="py-output">7.745966692414834</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(b, 2)
<span class="py-output">7.3484692283495345</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(a, -2)
<span class="py-output">0.0</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(b, -2)
<span class="py-output">1.8570331885190563e-016 # may vary</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(a, 3)
<span class="py-output">5.8480354764257312 # may vary</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(a, -3)
<span class="py-output">0.0</span>
</pre><p>Using the <code>axis</code> argument to compute vector norms:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>c = np.array([[ 1, 2, 3],
<span class="py-more">... </span>              [-1, 1, 4]])
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(c, axis=0)
<span class="py-output">array([ 1.41421356,  2.23606798,  5.        ])</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(c, axis=1)
<span class="py-output">array([ 3.74165739,  4.24264069])</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(c, <span class="py-builtin">ord</span>=1, axis=1)
<span class="py-output">array([ 6.,  6.])</span>
</pre><p>Using the <code>axis</code> argument to compute matrix norms:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>m = np.arange(8).reshape(2,2,2)
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(m, axis=(1,2))
<span class="py-output">array([  3.74165739,  11.22497216])</span>
<span class="py-prompt">&gt;&gt;&gt; </span>LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
<span class="py-output">(3.7416573867739413, 11.224972160321824)</span>
</pre></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">x:</span><code>array_like</code></td><td class="fieldArgDesc">Input array.  If <code>axis</code> is None, <code>x</code> must be 1-D or 2-D, unless <code><a href="https://docs.python.org/3/library/functions.html#ord" class="intersphinx-link">ord</a></code>
is None. If both <code>axis</code> and <code><a href="https://docs.python.org/3/library/functions.html#ord" class="intersphinx-link">ord</a></code> are None, the 2-norm of
<tt class="rst-docutils literal">x.ravel</tt> will be returned.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ord:</span><span class="literal">{non-zero int</span>, <span class="literal">inf</span>, <span class="literal">-inf</span>, <span class="literal">'fro'</span>, <span class="literal">'nuc'</span><span class="literal">}</span>, <em>optional</em></td><td class="fieldArgDesc">Order of the norm (see table under <tt class="rst-docutils literal">Notes</tt>). inf means numpy's
<code>inf</code> object. The default is None.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">axis:</span><span class="literal">{None</span>, <code><a href="https://docs.python.org/3/library/functions.html#int" class="intersphinx-link">int</a></code>, 2-tuple of <span class="literal">ints}</span>, <code>optional.</code></td><td class="fieldArgDesc"><p>If <code>axis</code> is an integer, it specifies the axis of <code>x</code> along which to
compute the vector norms.  If <code>axis</code> is a 2-tuple, it specifies the
axes that hold 2-D matrices, and the matrix norms of these matrices
are computed.  If <code>axis</code> is None then either a vector norm (when <code>x</code>
is 1-D) or a matrix norm (when <code>x</code> is 2-D) is returned. The default
is None.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.8.0.</span></div>
</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">keepdims:</span><code><a href="https://docs.python.org/3/library/functions.html#bool" class="intersphinx-link">bool</a></code>, <em>optional</em></td><td class="fieldArgDesc"><p>If this is set to True, the axes which are normed over are left in the
result as dimensions with size one.  With this option the result will
broadcast correctly against the original <code>x</code>.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.10.0.</span></div>
</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer"><code><a href="https://docs.python.org/3/library/functions.html#float" class="intersphinx-link">float</a></code> or <code>ndarray</code></td><td class="fieldArgDesc"><strong>n</strong> - Norm of the matrix or vector(s).</td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.pinv">
    
  </a>
  <a name="pinv">
    
  </a>
  <div class="functionHeader">
    @<a href="#array_function_dispatch" class="internal-link" title="numpy.linalg.linalg.array_function_dispatch">array_function_dispatch</a>(<wbr></wbr><a href="#_pinv_dispatcher" class="internal-link" title="numpy.linalg.linalg._pinv_dispatcher">_pinv_dispatcher</a>)<br />
    <span class="py-keyword">def</span> <span class="py-defname">pinv</span>(a, rcond=1e-15, hermitian=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L1897">
      
      (source)
    </a>
    <a class="headerLink" href="#pinv" title="numpy.linalg.linalg.pinv">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Compute the (Moore-Penrose) pseudo-inverse of a matrix.</p>
<p>Calculate the generalized inverse of a matrix using its
singular-value decomposition (SVD) and including all
<em>large</em> singular values.</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.14: </span><span>Can now operate on stacks of matrices</span></div>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<dl class="rst-last rst-docutils">
<dt><code>scipy.linalg.pinv</code></dt>
<dd>Similar function in SciPy.</dd>
<dt><code>scipy.linalg.pinvh</code></dt>
<dd>Compute the (Moore-Penrose) pseudo-inverse of a Hermitian matrix.</dd>
</dl>
</div>
<div class="rst-admonition rst-admonition-notes">
<p class="rst-first rst-admonition-title">Notes</p>
<p>The pseudo-inverse of a matrix A, denoted <span class="rst-formula"><i>A</i><sup> + </sup></span>, is
defined as: "the matrix that 'solves' [the least-squares problem]
<span class="rst-formula"><i>Ax</i> = <i>b</i></span>," i.e., if <span class="rst-formula"><span class="embellished"><sup>‒</sup><span class="base"><i>x</i></span></span></span> is said solution, then
<span class="rst-formula"><i>A</i><sup> + </sup></span> is that matrix such that <span class="rst-formula"><span class="embellished"><sup>‒</sup><span class="base"><i>x</i></span></span> = <i>A</i><sup> + </sup><i>b</i></span>.</p>
<p class="rst-last">It can be shown that if <span class="rst-formula"><i>Q</i><sub>1</sub>Σ<i>Q</i><span class="scripts"><sup class="script"><i>T</i></sup><sub class="script">2</sub></span> = <i>A</i></span> is the singular
value decomposition of A, then
<span class="rst-formula"><i>A</i><sup> + </sup> = <i>Q</i><sub>2</sub>Σ<sup> + </sup><i>Q</i><span class="scripts"><sup class="script"><i>T</i></sup><sub class="script">1</sub></span></span>, where <span class="rst-formula"><i>Q</i><sub>1, 2</sub></span> are
orthogonal matrices, <span class="rst-formula">Σ</span> is a diagonal matrix consisting
of A's so-called singular values, (followed, typically, by
zeros), and then <span class="rst-formula">Σ<sup> + </sup></span> is simply the diagonal matrix
consisting of the reciprocals of A's singular values
(again, followed by zeros). <a class="rst-footnote-reference" href="#rst-footnote-1" id="rst-footnote-reference-1">[1]</a></p>
</div>
<div class="rst-admonition rst-admonition-references">
<p class="rst-first rst-admonition-title">References</p>
<table class="rst-last rst-docutils footnote" frame="void" id="rst-footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="rst-label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>G. Strang, <em>Linear Algebra and Its Applications</em>, 2nd Ed., Orlando,
FL, Academic Press, Inc., 1980, pp. 139-142.</td></tr>
</tbody>
</table>
</div>
<div class="rst-admonition rst-admonition-examples">
<p class="rst-first rst-admonition-title">Examples</p>
<p>The following example checks that <tt class="rst-docutils literal">a * a+ * a == a</tt> and
<tt class="rst-docutils literal">a+ * a * a+ == a+</tt>:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.random.randn(9, 6)
<span class="py-prompt">&gt;&gt;&gt; </span>B = np.linalg.pinv(a)
<span class="py-prompt">&gt;&gt;&gt; </span>np.allclose(a, np.dot(a, np.dot(B, a)))
<span class="py-output">True</span>
<span class="py-prompt">&gt;&gt;&gt; </span>np.allclose(B, np.dot(B, np.dot(a, B)))
<span class="py-output">True</span>
</pre></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">a:</span>(<code>...</code>, <code>M</code>, <code>N)</code><blockquote>
array_like</blockquote>
</td><td class="fieldArgDesc">Matrix or stack of matrices to be pseudo-inverted.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">rcond:</span>(<code>...)</code><blockquote>
array_like</blockquote>
 of <code><a href="https://docs.python.org/3/library/functions.html#float" class="intersphinx-link">float</a></code></td><td class="fieldArgDesc">Cutoff for small singular values.
Singular values less than or equal to
<tt class="rst-docutils literal">rcond * largest_singular_value</tt> are set to zero.
Broadcasts against the stack of matrices.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">hermitian:</span><code><a href="https://docs.python.org/3/library/functions.html#bool" class="intersphinx-link">bool</a></code>, <em>optional</em></td><td class="fieldArgDesc"><p>If True, <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> is assumed to be Hermitian (symmetric if real-valued),
enabling a more efficient method for finding singular values.
Defaults to False.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.17.0.</span></div>
</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">(<code>...</code>, <code>N</code>, <code>M)</code><blockquote>
ndarray</blockquote>
</td><td class="fieldArgDesc"><strong>B</strong> - The pseudo-inverse of <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>. If <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> is a <code><a href="numpy.matrixlib.defmatrix.matrix.html" class="internal-link" title="numpy.matrixlib.defmatrix.matrix">matrix</a></code> instance, then so
is <code><a href="numpy.core.tests.test_scalarinherit.B.html" class="internal-link" title="numpy.core.tests.test_scalarinherit.B">B</a></code>.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Raises</td></tr><tr><td class="fieldArgContainer"><code><a href="numpy.linalg.linalg.LinAlgError.html" class="internal-link" title="numpy.linalg.linalg.LinAlgError">LinAlgError</a></code></td><td>If the SVD computation does not converge.</td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.qr">
    
  </a>
  <a name="qr">
    
  </a>
  <div class="functionHeader">
    @<a href="#array_function_dispatch" class="internal-link" title="numpy.linalg.linalg.array_function_dispatch">array_function_dispatch</a>(<wbr></wbr><a href="#_qr_dispatcher" class="internal-link" title="numpy.linalg.linalg._qr_dispatcher">_qr_dispatcher</a>)<br />
    <span class="py-keyword">def</span> <span class="py-defname">qr</span>(a, mode=<span class="rst-variable-quote">'</span><span class="rst-variable-string">reduced</span><span class="rst-variable-quote">'</span>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L766">
      
      (source)
    </a>
    <a class="headerLink" href="#qr" title="numpy.linalg.linalg.qr">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Compute the qr factorization of a matrix.</p>
<p>Factor the matrix <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> as <em>qr</em>, where <code>q</code> is orthonormal and <code>r</code> is
upper-triangular.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<dl class="rst-last rst-docutils">
<dt><code>scipy.linalg.qr</code></dt>
<dd>Similar function in SciPy.</dd>
<dt><code>scipy.linalg.rq</code></dt>
<dd>Compute RQ decomposition of a matrix.</dd>
</dl>
</div>
<div class="rst-admonition rst-admonition-notes">
<p class="rst-first rst-admonition-title">Notes</p>
<p>This is an interface to the LAPACK routines <tt class="rst-docutils literal">dgeqrf</tt>, <tt class="rst-docutils literal">zgeqrf</tt>,
<tt class="rst-docutils literal">dorgqr</tt>, and <tt class="rst-docutils literal">zungqr</tt>.</p>
<p>For more information on the qr factorization, see for example:
<a class="rst-reference external" href="https://en.wikipedia.org/wiki/QR_factorization" target="_top">https://en.wikipedia.org/wiki/QR_factorization</a></p>
<p>Subclasses of <code>ndarray</code> are preserved except for the 'raw' mode. So if
<code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> is of type <code><a href="numpy.matrixlib.defmatrix.matrix.html" class="internal-link" title="numpy.matrixlib.defmatrix.matrix">matrix</a></code>, all the return values will be matrices too.</p>
<p class="rst-last">New 'reduced', 'complete', and 'raw' options for mode were added in
NumPy 1.8.0 and the old option 'full' was made an alias of 'reduced'.  In
addition the options 'full' and 'economic' were deprecated.  Because
'full' was the previous default and 'reduced' is the new default,
backward compatibility can be maintained by letting <code>mode</code> default.
The 'raw' option was added so that LAPACK routines that can multiply
arrays by q using the Householder reflectors can be used. Note that in
this case the returned arrays are of type np.double or np.cdouble and
the h array is transposed to be FORTRAN compatible.  No routines using
the 'raw' return are currently exposed by numpy, but some are available
in lapack_lite and just await the necessary work.</p>
</div>
<div class="rst-admonition rst-admonition-examples">
<p class="rst-first rst-admonition-title">Examples</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.random.randn(9, 6)
<span class="py-prompt">&gt;&gt;&gt; </span>q, r = np.linalg.qr(a)
<span class="py-prompt">&gt;&gt;&gt; </span>np.allclose(a, np.dot(q, r))  <span class="py-comment"># a does equal qr</span>
<span class="py-output">True</span>
<span class="py-prompt">&gt;&gt;&gt; </span>r2 = np.linalg.qr(a, mode=<span class="py-string">'r'</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>np.allclose(r, r2)  <span class="py-comment"># mode='r' returns the same r as mode='full'</span>
<span class="py-output">True</span>
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.random.normal(size=(3, 2, 2)) <span class="py-comment"># Stack of 2 x 2 matrices as input</span>
<span class="py-prompt">&gt;&gt;&gt; </span>q, r = np.linalg.qr(a)
<span class="py-prompt">&gt;&gt;&gt; </span>q.shape
<span class="py-output">(3, 2, 2)</span>
<span class="py-prompt">&gt;&gt;&gt; </span>r.shape
<span class="py-output">(3, 2, 2)</span>
<span class="py-prompt">&gt;&gt;&gt; </span>np.allclose(a, np.matmul(q, r))
<span class="py-output">True</span>
</pre><p>Example illustrating a common use of <code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#qr" class="intersphinx-link">qr</a></code>: solving of least squares
problems</p>
<p>What are the least-squares-best <code><a href="numpy.doc.constants.html#m" class="internal-link" title="numpy.doc.constants.m">m</a></code> and <code>y0</code> in <tt class="rst-docutils literal">y = y0 + mx</tt> for
the following data: {(0,1), (1,0), (1,2), (2,1)}. (Graph the points
and you'll see that it should be y0 = 0, m = 1.)  The answer is provided
by solving the over-determined matrix equation <tt class="rst-docutils literal">Ax = b</tt>, where:</p>
<pre class="rst-literal-block">
A = array([[0, 1], [1, 1], [1, 1], [2, 1]])
x = array([[y0], [m]])
b = array([[1], [0], [2], [1]])
</pre>
<p>If A = qr such that q is orthonormal (which is always possible via
Gram-Schmidt), then <tt class="rst-docutils literal">x = inv(r) * (q.T) * b</tt>.  (In numpy practice,
however, we simply use <code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#lstsq" class="intersphinx-link">lstsq</a></code>.)</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>A = np.array([[0, 1], [1, 1], [1, 1], [2, 1]])
<span class="py-prompt">&gt;&gt;&gt; </span>A
<span class="py-output">array([[0, 1],</span>
<span class="py-output">       [1, 1],</span>
<span class="py-output">       [1, 1],</span>
<span class="py-output">       [2, 1]])</span>
<span class="py-prompt">&gt;&gt;&gt; </span>b = np.array([1, 2, 2, 3])
<span class="py-prompt">&gt;&gt;&gt; </span>q, r = np.linalg.qr(A)
<span class="py-prompt">&gt;&gt;&gt; </span>p = np.dot(q.T, b)
<span class="py-prompt">&gt;&gt;&gt; </span>np.dot(np.linalg.inv(r), p)
<span class="py-output">array([  1.,   1.])</span>
</pre></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">a:</span><code>array_like</code>, shape(<code>...</code>, <code>M</code>, <code>N)</code></td><td class="fieldArgDesc">An array-like object with the dimensionality of at least 2.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">mode:</span><span class="literal">{'reduced', 'complete', 'r', 'raw'}</span>, <em>optional</em></td><td class="fieldArgDesc"><p>If K = min(M, N), then</p>
<ul class="rst-simple">
<li><dl class="rst-first rst-docutils">
<dt>'reduced' <span class="classifier-delimiter">:</span> <span class="rst-classifier">returns q, r with dimensions</span></dt>
<dd>(..., M, K), (..., K, N) (default)</dd>
</dl>
</li>
<li>'complete' : returns q, r with dimensions (..., M, M), (..., M, N)</li>
<li>'r'        : returns r only with dimensions (..., K, N)</li>
<li>'raw'      : returns h, tau with dimensions (..., N, M), (..., K,)</li>
</ul>
<p>The options 'reduced', 'complete, and 'raw' are new in numpy 1.8,
see the notes for more information. The default is 'reduced', and to
maintain backward compatibility with earlier versions of numpy both
it and the old default 'full' can be omitted. Note that array h
returned in 'raw' mode is transposed for calling Fortran. The
'economic' mode is deprecated.  The modes 'full' and 'economic' may
be passed using only the first letter for backwards compatibility,
but all others must be spelled out. See the Notes for more
explanation.</p>
</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><ul class="rst-simple">
<li><strong>q</strong>: <code>ndarray</code> of <code><a href="https://docs.python.org/3/library/functions.html#float" class="intersphinx-link">float</a></code> or <code><a href="https://docs.python.org/3/library/functions.html#complex" class="intersphinx-link">complex</a></code>, <em>optional</em> - A matrix with orthonormal columns. When mode = 'complete' the
result is an orthogonal/unitary matrix depending on whether or not
a is real/complex. The determinant may be either +/- 1 in that
case. In case the number of dimensions in the input array is
greater than 2 then a stack of the matrices with above properties
is returned.</li>
<li><strong>r</strong>: <code>ndarray</code> of <code><a href="https://docs.python.org/3/library/functions.html#float" class="intersphinx-link">float</a></code> or <code><a href="https://docs.python.org/3/library/functions.html#complex" class="intersphinx-link">complex</a></code>, <em>optional</em> - The upper-triangular matrix or a stack of upper-triangular
matrices if the number of dimensions in the input array is greater
than 2.</li>
<li><strong>(h, tau)</strong>: <code>ndarrays</code> of <code>np.double</code> or <code>np.cdouble</code>, <em>optional</em> - The array h contains the Householder reflectors that generate q
along with r. The tau array contains scaling factors for the
reflectors. In the deprecated  'economic' mode only h is returned.</li>
</ul>
</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Raises</td></tr><tr><td class="fieldArgContainer"><code><a href="numpy.linalg.linalg.LinAlgError.html" class="internal-link" title="numpy.linalg.linalg.LinAlgError">LinAlgError</a></code></td><td>If factoring fails.</td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.slogdet">
    
  </a>
  <a name="slogdet">
    
  </a>
  <div class="functionHeader">
    @<a href="#array_function_dispatch" class="internal-link" title="numpy.linalg.linalg.array_function_dispatch">array_function_dispatch</a>(<wbr></wbr><a href="#_unary_dispatcher" class="internal-link" title="numpy.linalg.linalg._unary_dispatcher">_unary_dispatcher</a>)<br />
    <span class="py-keyword">def</span> <span class="py-defname">slogdet</span>(a):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L1998">
      
      (source)
    </a>
    <a class="headerLink" href="#slogdet" title="numpy.linalg.linalg.slogdet">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Compute the sign and (natural) logarithm of the determinant of an array.</p>
<p>If an array has a very small or very large determinant, then a call to
<code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#det" class="intersphinx-link">det</a></code> may overflow or underflow. This routine is more robust against such
issues, because it computes the logarithm of the determinant rather than
the determinant itself.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#det" class="intersphinx-link">det</a></code></p>
</div>
<div class="rst-admonition rst-admonition-notes">
<p class="rst-first rst-admonition-title">Notes</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.8.0.</span></div>
<p>Broadcasting rules apply, see the <code><a href="numpy.linalg.html" class="internal-link">numpy.linalg</a></code> documentation for
details.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.6.0.</span></div>
<p class="rst-last">The determinant is computed via LU factorization using the LAPACK
routine <tt class="rst-docutils literal">z/dgetrf</tt>.</p>
</div>
<div class="rst-admonition rst-admonition-examples">
<p class="rst-first rst-admonition-title">Examples</p>
<p>The determinant of a 2-D array <tt class="rst-docutils literal">[[a, b], [c, d]]</tt> is <tt class="rst-docutils literal">ad - bc</tt>:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[1, 2], [3, 4]])
<span class="py-prompt">&gt;&gt;&gt; </span>(sign, logdet) = np.linalg.slogdet(a)
<span class="py-prompt">&gt;&gt;&gt; </span>(sign, logdet)
<span class="py-output">(-1, 0.69314718055994529) # may vary</span>
<span class="py-prompt">&gt;&gt;&gt; </span>sign * np.exp(logdet)
<span class="py-output">-2.0</span>
</pre><p>Computing log-determinants for a stack of matrices:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
<span class="py-prompt">&gt;&gt;&gt; </span>a.shape
<span class="py-output">(3, 2, 2)</span>
<span class="py-prompt">&gt;&gt;&gt; </span>sign, logdet = np.linalg.slogdet(a)
<span class="py-prompt">&gt;&gt;&gt; </span>(sign, logdet)
<span class="py-output">(array([-1., -1., -1.]), array([ 0.69314718,  1.09861229,  2.07944154]))</span>
<span class="py-prompt">&gt;&gt;&gt; </span>sign * np.exp(logdet)
<span class="py-output">array([-2., -3., -8.])</span>
</pre><p>This routine succeeds where ordinary <code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#det" class="intersphinx-link">det</a></code> does not:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.linalg.det(np.eye(500) * 0.1)
<span class="py-output">0.0</span>
<span class="py-prompt">&gt;&gt;&gt; </span>np.linalg.slogdet(np.eye(500) * 0.1)
<span class="py-output">(1, -1151.2925464970228)</span>
</pre></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">a:</span>(<code>...</code>, <code>M</code>, <code>M)</code><blockquote>
array_like</blockquote>
</td><td class="fieldArgDesc">Input array, has to be a square 2-D array.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">If the determinant is zero, then <code><a href="numpy.array_api._elementwise_functions.html#sign" class="internal-link" title="numpy.array_api._elementwise_functions.sign">sign</a></code> will be 0 and <code>logdet</code> will be
-Inf. In all cases, the determinant is equal to <tt class="rst-docutils literal">sign * np.exp(logdet)</tt>.</td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.solve">
    
  </a>
  <a name="solve">
    
  </a>
  <div class="functionHeader">
    @<a href="#array_function_dispatch" class="internal-link" title="numpy.linalg.linalg.array_function_dispatch">array_function_dispatch</a>(<wbr></wbr><a href="#_solve_dispatcher" class="internal-link" title="numpy.linalg.linalg._solve_dispatcher">_solve_dispatcher</a>)<br />
    <span class="py-keyword">def</span> <span class="py-defname">solve</span>(a, b):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L306">
      
      (source)
    </a>
    <a class="headerLink" href="#solve" title="numpy.linalg.linalg.solve">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Solve a linear matrix equation, or system of linear scalar equations.</p>
<p>Computes the "exact" solution, <code>x</code>, of the well-determined, i.e., full
rank, linear matrix equation <code>ax = b</code>.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<dl class="rst-last rst-docutils">
<dt><code>scipy.linalg.solve</code></dt>
<dd>Similar function in SciPy.</dd>
</dl>
</div>
<div class="rst-admonition rst-admonition-notes">
<p class="rst-first rst-admonition-title">Notes</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.8.0.</span></div>
<p>Broadcasting rules apply, see the <code><a href="numpy.linalg.html" class="internal-link">numpy.linalg</a></code> documentation for
details.</p>
<p>The solutions are computed using LAPACK routine <tt class="rst-docutils literal">_gesv</tt>.</p>
<p class="rst-last"><code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> must be square and of full-rank, i.e., all rows (or, equivalently,
columns) must be linearly independent; if either is not true, use
<code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#lstsq" class="intersphinx-link">lstsq</a></code> for the least-squares best "solution" of the
system/equation.</p>
</div>
<div class="rst-admonition rst-admonition-references">
<p class="rst-first rst-admonition-title">References</p>
<table class="rst-last rst-docutils footnote" frame="void" id="rst-footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="rst-label">[1]</td><td>G. Strang, <em>Linear Algebra and Its Applications</em>, 2nd Ed., Orlando,
FL, Academic Press, Inc., 1980, pg. 22.</td></tr>
</tbody>
</table>
</div>
<div class="rst-admonition rst-admonition-examples">
<p class="rst-first rst-admonition-title">Examples</p>
<p>Solve the system of equations <tt class="rst-docutils literal">x0 + 2 * x1 = 1</tt> and <tt class="rst-docutils literal">3 * x0 + 5 * x1 = 2</tt>:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.array([[1, 2], [3, 5]])
<span class="py-prompt">&gt;&gt;&gt; </span>b = np.array([1, 2])
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.linalg.solve(a, b)
<span class="py-prompt">&gt;&gt;&gt; </span>x
<span class="py-output">array([-1.,  1.])</span>
</pre><p>Check that the solution is correct:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>np.allclose(np.dot(a, x), b)
<span class="py-output">True</span>
</pre></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">a:</span>(<code>...</code>, <code>M</code>, <code>M)</code><blockquote>
array_like</blockquote>
</td><td class="fieldArgDesc">Coefficient matrix.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">b:</span><span class="literal">{(..., M, ), (..., M, K)}</span>, <code>array_like</code></td><td class="fieldArgDesc">Ordinate or "dependent variable" values.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer"><span class="literal">{(..., M, ), (..., M, K)} ndarray</span></td><td class="fieldArgDesc"><strong>x</strong> - Solution to the system a x = b.  Returned shape is identical to <code>b</code>.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Raises</td></tr><tr><td class="fieldArgContainer"><code><a href="numpy.linalg.linalg.LinAlgError.html" class="internal-link" title="numpy.linalg.linalg.LinAlgError">LinAlgError</a></code></td><td>If <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> is singular or not square.</td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.svd">
    
  </a>
  <a name="svd">
    
  </a>
  <div class="functionHeader">
    @<a href="#array_function_dispatch" class="internal-link" title="numpy.linalg.linalg.array_function_dispatch">array_function_dispatch</a>(<wbr></wbr><a href="#_svd_dispatcher" class="internal-link" title="numpy.linalg.linalg._svd_dispatcher">_svd_dispatcher</a>)<br />
    <span class="py-keyword">def</span> <span class="py-defname">svd</span>(a, full_matrices=<a href="https://docs.python.org/3/library/constants.html#True" class="intersphinx-link">True</a>, compute_uv=<a href="https://docs.python.org/3/library/constants.html#True" class="intersphinx-link">True</a>, hermitian=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L1463">
      
      (source)
    </a>
    <a class="headerLink" href="#svd" title="numpy.linalg.linalg.svd">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Singular Value Decomposition.</p>
<p>When <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> is a 2D array, and <tt class="rst-docutils literal">full_matrices=False</tt>, then it is
factorized as <tt class="rst-docutils literal">u @ np.diag(s) @ vh = (u * s) @ vh</tt>, where
<code>u</code> and the Hermitian transpose of <code>vh</code> are 2D arrays with
orthonormal columns and <code><a href="numpy.doc.constants.html#s" class="internal-link" title="numpy.doc.constants.s">s</a></code> is a 1D array of <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>'s singular
values. When <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> is higher-dimensional, SVD is applied in
stacked mode as explained below.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<dl class="rst-last rst-docutils">
<dt><code>scipy.linalg.svd</code></dt>
<dd>Similar function in SciPy.</dd>
<dt><code>scipy.linalg.svdvals</code></dt>
<dd>Compute singular values of a matrix.</dd>
</dl>
</div>
<div class="rst-admonition rst-admonition-notes">
<p class="rst-first rst-admonition-title">Notes</p>
<div class="rst-versionchanged">
<span class="rst-versionmodified rst-changed">Changed in version 1.8.0: </span><span>Broadcasting rules apply, see the <code><a href="numpy.linalg.html" class="internal-link">numpy.linalg</a></code> documentation for
details.</span></div>
<p>The decomposition is performed using LAPACK routine <tt class="rst-docutils literal">_gesdd</tt>.</p>
<p>SVD is usually described for the factorization of a 2D matrix <span class="rst-formula"><i>A</i></span>.
The higher-dimensional case will be discussed below. In the 2D case, SVD is
written as <span class="rst-formula"><i>A</i> = <i>U</i><i>S</i><i>V</i><sup><i>H</i></sup></span>, where <span class="rst-formula"><i>A</i> = <i>a</i></span>, <span class="rst-formula"><i>U</i> = <i>u</i></span>,
<span class="rst-formula"><i>S</i> = <span class="mathtt">np.diag</span>(<i>s</i>)</span> and <span class="rst-formula"><i>V</i><sup><i>H</i></sup> = <i>vh</i></span>. The 1D array <code><a href="numpy.doc.constants.html#s" class="internal-link" title="numpy.doc.constants.s">s</a></code>
contains the singular values of <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> and <code>u</code> and <code>vh</code> are unitary. The rows
of <code>vh</code> are the eigenvectors of <span class="rst-formula"><i>A</i><sup><i>H</i></sup><i>A</i></span> and the columns of <code>u</code> are
the eigenvectors of <span class="rst-formula"><i>A</i><i>A</i><sup><i>H</i></sup></span>. In both cases the corresponding
(possibly non-zero) eigenvalues are given by <tt class="rst-docutils literal"><span class="pre">s**2</span></tt>.</p>
<p>If <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> has more than two dimensions, then broadcasting rules apply, as
explained in :ref:`routines.linalg-broadcasting`. This means that SVD is
working in "stacked" mode: it iterates over all indices of the first
<tt class="rst-docutils literal">a.ndim - 2</tt> dimensions and for each combination SVD is applied to the
last two indices. The matrix <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> can be reconstructed from the
decomposition with either <tt class="rst-docutils literal">(u * <span class="pre">s[...,</span> None, :]) @ vh</tt> or
<tt class="rst-docutils literal">u @ <span class="pre">(s[...,</span> None] * vh)</tt>. (The <tt class="rst-docutils literal">@</tt> operator can be replaced by the
function <tt class="rst-docutils literal">np.matmul</tt> for python versions below 3.5.)</p>
<p class="rst-last">If <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> is a <tt class="rst-docutils literal">matrix</tt> object (as opposed to an <tt class="rst-docutils literal">ndarray</tt>), then so are
all the return values.</p>
</div>
<div class="rst-admonition rst-admonition-examples">
<p class="rst-first rst-admonition-title">Examples</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.random.randn(9, 6) + 1j*np.random.randn(9, 6)
<span class="py-prompt">&gt;&gt;&gt; </span>b = np.random.randn(2, 7, 8, 3) + 1j*np.random.randn(2, 7, 8, 3)</pre><p>Reconstruction based on full SVD, 2D case:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>u, s, vh = np.linalg.svd(a, full_matrices=<span class="py-builtin">True</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>u.shape, s.shape, vh.shape
<span class="py-output">((9, 9), (6,), (6, 6))</span>
<span class="py-prompt">&gt;&gt;&gt; </span>np.allclose(a, np.dot(u[:, :6] * s, vh))
<span class="py-output">True</span>
<span class="py-prompt">&gt;&gt;&gt; </span>smat = np.zeros((9, 6), dtype=<span class="py-builtin">complex</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>smat[:6, :6] = np.diag(s)
<span class="py-prompt">&gt;&gt;&gt; </span>np.allclose(a, np.dot(u, np.dot(smat, vh)))
<span class="py-output">True</span>
</pre><p>Reconstruction based on reduced SVD, 2D case:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>u, s, vh = np.linalg.svd(a, full_matrices=<span class="py-builtin">False</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>u.shape, s.shape, vh.shape
<span class="py-output">((9, 6), (6,), (6, 6))</span>
<span class="py-prompt">&gt;&gt;&gt; </span>np.allclose(a, np.dot(u * s, vh))
<span class="py-output">True</span>
<span class="py-prompt">&gt;&gt;&gt; </span>smat = np.diag(s)
<span class="py-prompt">&gt;&gt;&gt; </span>np.allclose(a, np.dot(u, np.dot(smat, vh)))
<span class="py-output">True</span>
</pre><p>Reconstruction based on full SVD, 4D case:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>u, s, vh = np.linalg.svd(b, full_matrices=<span class="py-builtin">True</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>u.shape, s.shape, vh.shape
<span class="py-output">((2, 7, 8, 8), (2, 7, 3), (2, 7, 3, 3))</span>
<span class="py-prompt">&gt;&gt;&gt; </span>np.allclose(b, np.matmul(u[..., :3] * s[..., <span class="py-builtin">None</span>, :], vh))
<span class="py-output">True</span>
<span class="py-prompt">&gt;&gt;&gt; </span>np.allclose(b, np.matmul(u[..., :3], s[..., <span class="py-builtin">None</span>] * vh))
<span class="py-output">True</span>
</pre><p>Reconstruction based on reduced SVD, 4D case:</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>u, s, vh = np.linalg.svd(b, full_matrices=<span class="py-builtin">False</span>)
<span class="py-prompt">&gt;&gt;&gt; </span>u.shape, s.shape, vh.shape
<span class="py-output">((2, 7, 8, 3), (2, 7, 3), (2, 7, 3, 3))</span>
<span class="py-prompt">&gt;&gt;&gt; </span>np.allclose(b, np.matmul(u * s[..., <span class="py-builtin">None</span>, :], vh))
<span class="py-output">True</span>
<span class="py-prompt">&gt;&gt;&gt; </span>np.allclose(b, np.matmul(u, s[..., <span class="py-builtin">None</span>] * vh))
<span class="py-output">True</span>
</pre></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">a:</span>(<code>...</code>, <code>M</code>, <code>N)</code><blockquote>
array_like</blockquote>
</td><td class="fieldArgDesc">A real or complex array with <tt class="rst-docutils literal">a.ndim &gt;= 2</tt>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">full<wbr></wbr>_matrices:</span><code><a href="https://docs.python.org/3/library/functions.html#bool" class="intersphinx-link">bool</a></code>, <em>optional</em></td><td class="fieldArgDesc">If True (default), <code>u</code> and <code>vh</code> have the shapes <tt class="rst-docutils literal"><span class="pre">(...,</span> M, M)</tt> and
<tt class="rst-docutils literal"><span class="pre">(...,</span> N, N)</tt>, respectively.  Otherwise, the shapes are
<tt class="rst-docutils literal"><span class="pre">(...,</span> M, K)</tt> and <tt class="rst-docutils literal"><span class="pre">(...,</span> K, N)</tt>, respectively, where
<tt class="rst-docutils literal">K = min(M, N)</tt>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">compute<wbr></wbr>_uv:</span><code><a href="https://docs.python.org/3/library/functions.html#bool" class="intersphinx-link">bool</a></code>, <em>optional</em></td><td class="fieldArgDesc">Whether or not to compute <code>u</code> and <code>vh</code> in addition to <code><a href="numpy.doc.constants.html#s" class="internal-link" title="numpy.doc.constants.s">s</a></code>.  True
by default.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">hermitian:</span><code><a href="https://docs.python.org/3/library/functions.html#bool" class="intersphinx-link">bool</a></code>, <em>optional</em></td><td class="fieldArgDesc"><p>If True, <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> is assumed to be Hermitian (symmetric if real-valued),
enabling a more efficient method for finding singular values.
Defaults to False.</p>
<div class="rst-versionadded">
<span class="rst-versionmodified rst-added">New in version 1.17.0.</span></div>
</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2"><ul class="rst-simple">
<li><strong>u</strong>: <tt class="rst-docutils literal">{ ``\ <span class="pre">(`...`,</span> `M`, <span class="pre">`M`),</span> <span class="pre">(`...`,</span> `M`, `K`\ ) } array - Unitary array(s). The first ``a.ndim - 2</tt> dimensions have the same
size as those of the input <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>. The size of the last two dimensions
depends on the value of <code>full_matrices</code>. Only returned when
<code>compute_uv</code> is True.</li>
<li><strong>s</strong>: (<code>...</code>, <code>K</code>) array - Vector(s) with the singular values, within each vector sorted in
descending order. The first <tt class="rst-docutils literal">a.ndim - 2</tt> dimensions have the same
size as those of the input <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>.</li>
<li><strong>vh</strong>: <tt class="rst-docutils literal">{ ``\ <span class="pre">(`...`,</span> `N`, <span class="pre">`N`),</span> <span class="pre">(`...`,</span> `K`, `N`\ ) } array - Unitary array(s). The first ``a.ndim - 2</tt> dimensions have the same
size as those of the input <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>. The size of the last two dimensions
depends on the value of <code>full_matrices</code>. Only returned when
<code>compute_uv</code> is True.</li>
</ul>
</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Raises</td></tr><tr><td class="fieldArgContainer"><code><a href="numpy.linalg.linalg.LinAlgError.html" class="internal-link" title="numpy.linalg.linalg.LinAlgError">LinAlgError</a></code></td><td>If SVD computation does not converge.</td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.tensorinv">
    
  </a>
  <a name="tensorinv">
    
  </a>
  <div class="functionHeader">
    @<a href="#array_function_dispatch" class="internal-link" title="numpy.linalg.linalg.array_function_dispatch">array_function_dispatch</a>(<wbr></wbr><a href="#_tensorinv_dispatcher" class="internal-link" title="numpy.linalg.linalg._tensorinv_dispatcher">_tensorinv_dispatcher</a>)<br />
    <span class="py-keyword">def</span> <span class="py-defname">tensorinv</span>(a, ind=2):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L395">
      
      (source)
    </a>
    <a class="headerLink" href="#tensorinv" title="numpy.linalg.linalg.tensorinv">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Compute the 'inverse' of an N-dimensional array.</p>
<p>The result is an inverse for <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> relative to the tensordot operation
<tt class="rst-docutils literal">tensordot(a, b, ind)</tt>, i. e., up to floating-point accuracy,
<tt class="rst-docutils literal">tensordot(tensorinv(a), a, ind)</tt> is the "identity" tensor for the
tensordot operation.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>numpy.tensordot</code>, <code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#tensorsolve" class="intersphinx-link">tensorsolve</a></code></p>
</div>
<div class="rst-admonition rst-admonition-examples">
<p class="rst-first rst-admonition-title">Examples</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.eye(4*6)
<span class="py-prompt">&gt;&gt;&gt; </span>a.shape = (4, 6, 8, 3)
<span class="py-prompt">&gt;&gt;&gt; </span>ainv = np.linalg.tensorinv(a, ind=2)
<span class="py-prompt">&gt;&gt;&gt; </span>ainv.shape
<span class="py-output">(8, 3, 4, 6)</span>
<span class="py-prompt">&gt;&gt;&gt; </span>b = np.random.randn(4, 6)
<span class="py-prompt">&gt;&gt;&gt; </span>np.allclose(np.tensordot(ainv, b), np.linalg.tensorsolve(a, b))
<span class="py-output">True</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.eye(4*6)
<span class="py-prompt">&gt;&gt;&gt; </span>a.shape = (24, 8, 3)
<span class="py-prompt">&gt;&gt;&gt; </span>ainv = np.linalg.tensorinv(a, ind=1)
<span class="py-prompt">&gt;&gt;&gt; </span>ainv.shape
<span class="py-output">(8, 3, 24)</span>
<span class="py-prompt">&gt;&gt;&gt; </span>b = np.random.randn(24)
<span class="py-prompt">&gt;&gt;&gt; </span>np.allclose(np.tensordot(ainv, b, 1), np.linalg.tensorsolve(a, b))
<span class="py-output">True</span>
</pre></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">a:</span><code>array_like</code></td><td class="fieldArgDesc">Tensor to 'invert'. Its shape must be 'square', i. e.,
<tt class="rst-docutils literal"><span class="pre">prod(a.shape[:ind])</span> == <span class="pre">prod(a.shape[ind:])</span></tt>.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ind:</span><code><a href="https://docs.python.org/3/library/functions.html#int" class="intersphinx-link">int</a></code>, <em>optional</em></td><td class="fieldArgDesc">Number of first indices that are involved in the inverse sum.
Must be a positive integer, default is 2.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer"><code>ndarray</code></td><td class="fieldArgDesc"><strong>b</strong> - <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>'s tensordot inverse, shape <tt class="rst-docutils literal">a.shape[ind:] + <span class="pre">a.shape[:ind]</span></tt>.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Raises</td></tr><tr><td class="fieldArgContainer"><code><a href="numpy.linalg.linalg.LinAlgError.html" class="internal-link" title="numpy.linalg.linalg.LinAlgError">LinAlgError</a></code></td><td>If <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> is singular or not 'square' (in the above sense).</td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.tensorsolve">
    
  </a>
  <a name="tensorsolve">
    
  </a>
  <div class="functionHeader">
    @<a href="#array_function_dispatch" class="internal-link" title="numpy.linalg.linalg.array_function_dispatch">array_function_dispatch</a>(<wbr></wbr><a href="#_tensorsolve_dispatcher" class="internal-link" title="numpy.linalg.linalg._tensorsolve_dispatcher">_tensorsolve_dispatcher</a>)<br />
    <span class="py-keyword">def</span> <span class="py-defname">tensorsolve</span>(a, b, axes=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L225">
      
      (source)
    </a>
    <a class="headerLink" href="#tensorsolve" title="numpy.linalg.linalg.tensorsolve">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Solve the tensor equation <tt class="rst-docutils literal">a x = b</tt> for x.</p>
<p>It is assumed that all indices of <code>x</code> are summed over in the product,
together with the rightmost indices of <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code>, as is done in, for example,
<tt class="rst-docutils literal">tensordot(a, x, axes=x.ndim)</tt>.</p>
<div class="rst-admonition seealso">
<p class="rst-first rst-admonition-title">See Also</p>
<p class="rst-last"><code>numpy.tensordot</code>, <code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#tensorinv" class="intersphinx-link">tensorinv</a></code>, <code>numpy.einsum</code></p>
</div>
<div class="rst-admonition rst-admonition-examples">
<p class="rst-first rst-admonition-title">Examples</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>a = np.eye(2*3*4)
<span class="py-prompt">&gt;&gt;&gt; </span>a.shape = (2*3, 4, 2, 3, 4)
<span class="py-prompt">&gt;&gt;&gt; </span>b = np.random.randn(2*3, 4)
<span class="py-prompt">&gt;&gt;&gt; </span>x = np.linalg.tensorsolve(a, b)
<span class="py-prompt">&gt;&gt;&gt; </span>x.shape
<span class="py-output">(2, 3, 4)</span>
<span class="py-prompt">&gt;&gt;&gt; </span>np.allclose(np.tensordot(a, x, axes=3), b)
<span class="py-output">True</span>
</pre></div>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">a:</span><code>array_like</code></td><td class="fieldArgDesc">Coefficient tensor, of shape <tt class="rst-docutils literal">b.shape + Q</tt>. <code>Q</code>, a tuple, equals
the shape of that sub-tensor of <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> consisting of the appropriate
number of its rightmost indices, and must be such that
<tt class="rst-docutils literal">prod(Q) == prod(b.shape)</tt> (in which sense <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> is said to be
'square').</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">b:</span><code>array_like</code></td><td class="fieldArgDesc">Right-hand tensor, which can be of any shape.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">axes:</span><code><a href="https://docs.python.org/3/library/stdtypes.html#tuple" class="intersphinx-link">tuple</a></code> of <code><a href="numpy.core.code_generators.generate_umath.html#ints" class="internal-link" title="numpy.core.code_generators.generate_umath.ints">ints</a></code>, <em>optional</em></td><td class="fieldArgDesc">Axes in <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> to reorder to the right, before inversion.
If None (default), no reordering is done.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">xndarray, shape Q</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Raises</td></tr><tr><td class="fieldArgContainer"><code><a href="numpy.linalg.linalg.LinAlgError.html" class="internal-link" title="numpy.linalg.linalg.LinAlgError">LinAlgError</a></code></td><td>If <code><a href="numpy._pyinstaller.pyinstaller-smoke.html#a" class="internal-link" title="numpy._pyinstaller.pyinstaller-smoke.a">a</a></code> is singular or not 'square' (in the above sense).</td></tr></table></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="numpy.linalg.linalg.transpose">
    
  </a>
  <a name="transpose">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">transpose</span>(a):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L202">
      
      (source)
    </a>
    <a class="headerLink" href="#transpose" title="numpy.linalg.linalg.transpose">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Transpose each matrix in a stack of matrices.</p>
<p>Unlike np.transpose, this only swaps the last two axes, rather than all of
them</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">a:</span>(<code>...</code>, <code>M</code>, <code>N)</code><blockquote>
array_like</blockquote>
</td><td class="fieldArgDesc"></td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td colspan="2">aT(...,N,M) ndarray</td></tr></table></div>
  </div>
</div><div class="basevariable">
  
  
  <a name="numpy.linalg.linalg.array_function_dispatch">
    
  </a>
  <a name="array_function_dispatch">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">array_function_dispatch</span> =
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L37">
      
      (source)
    </a>
    <a class="headerLink" href="#array_function_dispatch" title="numpy.linalg.linalg.array_function_dispatch">
      
      
      ¶
    </a>
  </div>
  <div class="functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._assert_2d">
    
  </a>
  <a name="_assert_2d">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_assert_2d</span>(*arrays):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L174">
      
      (source)
    </a>
    <a class="headerLink" href="#_assert_2d" title="numpy.linalg.linalg._assert_2d">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._assert_finite">
    
  </a>
  <a name="_assert_finite">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_assert_finite</span>(*arrays):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L192">
      
      (source)
    </a>
    <a class="headerLink" href="#_assert_finite" title="numpy.linalg.linalg._assert_finite">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._assert_stacked_2d">
    
  </a>
  <a name="_assert_stacked_2d">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_assert_stacked_2d</span>(*arrays):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L180">
      
      (source)
    </a>
    <a class="headerLink" href="#_assert_stacked_2d" title="numpy.linalg.linalg._assert_stacked_2d">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._assert_stacked_square">
    
  </a>
  <a name="_assert_stacked_square">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_assert_stacked_square</span>(*arrays):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L186">
      
      (source)
    </a>
    <a class="headerLink" href="#_assert_stacked_square" title="numpy.linalg.linalg._assert_stacked_square">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._commonType">
    
  </a>
  <a name="_commonType">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_commonType</span>(*arrays):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L136">
      
      (source)
    </a>
    <a class="headerLink" href="#_commonType" title="numpy.linalg.linalg._commonType">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._complexType">
    
  </a>
  <a name="_complexType">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_complexType</span>(t, default=cdouble):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L133">
      
      (source)
    </a>
    <a class="headerLink" href="#_complexType" title="numpy.linalg.linalg._complexType">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._cond_dispatcher">
    
  </a>
  <a name="_cond_dispatcher">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_cond_dispatcher</span>(x, p=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L1659">
      
      (source)
    </a>
    <a class="headerLink" href="#_cond_dispatcher" title="numpy.linalg.linalg._cond_dispatcher">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._convertarray">
    
  </a>
  <a name="_convertarray">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_convertarray</span>(a):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L1159">
      
      (source)
    </a>
    <a class="headerLink" href="#_convertarray" title="numpy.linalg.linalg._convertarray">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._determine_error_states">
    
  </a>
  <a name="_determine_error_states">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_determine_error_states</span>():
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L74">
      
      (source)
    </a>
    <a class="headerLink" href="#_determine_error_states" title="numpy.linalg.linalg._determine_error_states">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._eigvalsh_dispatcher">
    
  </a>
  <a name="_eigvalsh_dispatcher">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_eigvalsh_dispatcher</span>(a, UPLO=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L1061">
      
      (source)
    </a>
    <a class="headerLink" href="#_eigvalsh_dispatcher" title="numpy.linalg.linalg._eigvalsh_dispatcher">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._is_empty_2d">
    
  </a>
  <a name="_is_empty_2d">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_is_empty_2d</span>(arr):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L197">
      
      (source)
    </a>
    <a class="headerLink" href="#_is_empty_2d" title="numpy.linalg.linalg._is_empty_2d">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._lstsq_dispatcher">
    
  </a>
  <a name="_lstsq_dispatcher">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_lstsq_dispatcher</span>(a, b, rcond=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L2146">
      
      (source)
    </a>
    <a class="headerLink" href="#_lstsq_dispatcher" title="numpy.linalg.linalg._lstsq_dispatcher">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._makearray">
    
  </a>
  <a name="_makearray">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_makearray</span>(a):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L112">
      
      (source)
    </a>
    <a class="headerLink" href="#_makearray" title="numpy.linalg.linalg._makearray">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._matrix_power_dispatcher">
    
  </a>
  <a name="_matrix_power_dispatcher">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_matrix_power_dispatcher</span>(a, n):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L542">
      
      (source)
    </a>
    <a class="headerLink" href="#_matrix_power_dispatcher" title="numpy.linalg.linalg._matrix_power_dispatcher">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._matrix_rank_dispatcher">
    
  </a>
  <a name="_matrix_rank_dispatcher">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_matrix_rank_dispatcher</span>(A, tol=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, hermitian=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L1782">
      
      (source)
    </a>
    <a class="headerLink" href="#_matrix_rank_dispatcher" title="numpy.linalg.linalg._matrix_rank_dispatcher">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._multi_dot">
    
  </a>
  <a name="_multi_dot">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_multi_dot</span>(arrays, order, i, j, out=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L2785">
      
      (source)
    </a>
    <a class="headerLink" href="#_multi_dot" title="numpy.linalg.linalg._multi_dot">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Actually do the multiplication with the given order.</p>
</div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._multi_dot_matrix_chain_order">
    
  </a>
  <a name="_multi_dot_matrix_chain_order">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_multi_dot_matrix_chain_order</span>(arrays, return_costs=<a href="https://docs.python.org/3/library/constants.html#False" class="intersphinx-link">False</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L2744">
      
      (source)
    </a>
    <a class="headerLink" href="#_multi_dot_matrix_chain_order" title="numpy.linalg.linalg._multi_dot_matrix_chain_order">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Return a np.array that encodes the optimal order of mutiplications.</p>
<p>The optimal order array is then used by <code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#_multi_dot" class="intersphinx-link">_multi_dot()</a></code> to do the
multiplication.</p>
<p>Also return the cost matrix if <code>return_costs</code> is <code><a href="https://docs.python.org/3/library/constants.html#True" class="intersphinx-link">True</a></code></p>
<p>The implementation CLOSELY follows Cormen, "Introduction to Algorithms",
Chapter 15.2, p. 370-378.  Note that Cormen uses 1-based indices.</p>
<blockquote>
<dl class="rst-docutils">
<dt>cost[i, j] = min([</dt>
<dd>cost[prefix] + cost[suffix] + cost_mult(prefix, suffix)
for k in range(i, j)])</dd>
</dl>
</blockquote>
</div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._multi_dot_three">
    
  </a>
  <a name="_multi_dot_three">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_multi_dot_three</span>(A, B, C, out=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L2723">
      
      (source)
    </a>
    <a class="headerLink" href="#_multi_dot_three" title="numpy.linalg.linalg._multi_dot_three">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Find the best order for three arrays and do the multiplication.</p>
<p>For three arguments <code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#_multi_dot_three" class="intersphinx-link">_multi_dot_three</a></code> is approximately 15 times faster
than <code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#_multi_dot_matrix_chain_order" class="intersphinx-link">_multi_dot_matrix_chain_order</a></code></p>
</div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._multi_svd_norm">
    
  </a>
  <a name="_multi_svd_norm">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_multi_svd_norm</span>(x, row_axis, col_axis, op):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L2310">
      
      (source)
    </a>
    <a class="headerLink" href="#_multi_svd_norm" title="numpy.linalg.linalg._multi_svd_norm">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p>Compute a function of the singular values of the 2-D matrices in <code>x</code>.</p>
<p>This is a private utility function used by <code><a href="https://pydocbrowser.github.io/numpy/latest/numpy.linalg.linalg.html#norm" class="intersphinx-link">numpy.linalg.norm()</a></code>.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">x:</span><code>ndarray</code></td><td class="fieldArgDesc"></td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">row<wbr></wbr>_axis:</span><code><a href="https://docs.python.org/3/library/functions.html#int" class="intersphinx-link">int</a></code></td><td class="fieldArgDesc">The axes of <code>x</code> that hold the 2-D matrices.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">col<wbr></wbr>_axis:</span><code><a href="https://docs.python.org/3/library/functions.html#int" class="intersphinx-link">int</a></code></td><td class="fieldArgDesc">The axes of <code>x</code> that hold the 2-D matrices.</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">op:</span><code><a href="https://docs.python.org/3/library/functions.html#callable" class="intersphinx-link">callable</a></code></td><td class="fieldArgDesc">This should be either numpy.amin or <code>numpy.amax</code> or <code>numpy.sum</code>.</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer"><code><a href="https://docs.python.org/3/library/functions.html#float" class="intersphinx-link">float</a></code> or <code>ndarray</code></td><td class="fieldArgDesc"><strong>result</strong> - If <code>x</code> is 2-D, the return values is a float.
Otherwise, it is an array with <tt class="rst-docutils literal">x.ndim - 2</tt> dimensions.
The return values are either the minimum or maximum or sum of the
singular values of the matrices, depending on whether <code>op</code>
is <code>numpy.amin</code> or <code>numpy.amax</code> or <code>numpy.sum</code>.</td></tr></table></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._multidot_dispatcher">
    
  </a>
  <a name="_multidot_dispatcher">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_multidot_dispatcher</span>(arrays, *, out=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L2597">
      
      (source)
    </a>
    <a class="headerLink" href="#_multidot_dispatcher" title="numpy.linalg.linalg._multidot_dispatcher">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._norm_dispatcher">
    
  </a>
  <a name="_norm_dispatcher">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_norm_dispatcher</span>(x, ord=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, axis=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, keepdims=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L2338">
      
      (source)
    </a>
    <a class="headerLink" href="#_norm_dispatcher" title="numpy.linalg.linalg._norm_dispatcher">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._pinv_dispatcher">
    
  </a>
  <a name="_pinv_dispatcher">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_pinv_dispatcher</span>(a, rcond=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, hermitian=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L1893">
      
      (source)
    </a>
    <a class="headerLink" href="#_pinv_dispatcher" title="numpy.linalg.linalg._pinv_dispatcher">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._qr_dispatcher">
    
  </a>
  <a name="_qr_dispatcher">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_qr_dispatcher</span>(a, mode=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L762">
      
      (source)
    </a>
    <a class="headerLink" href="#_qr_dispatcher" title="numpy.linalg.linalg._qr_dispatcher">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._raise_linalgerror_eigenvalues_nonconvergence">
    
  </a>
  <a name="_raise_linalgerror_eigenvalues_nonconvergence">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_raise_linalgerror_eigenvalues_nonconvergence</span>(err, flag):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L94">
      
      (source)
    </a>
    <a class="headerLink" href="#_raise_linalgerror_eigenvalues_nonconvergence" title="numpy.linalg.linalg._raise_linalgerror_eigenvalues_nonconvergence">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._raise_linalgerror_lstsq">
    
  </a>
  <a name="_raise_linalgerror_lstsq">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_raise_linalgerror_lstsq</span>(err, flag):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L100">
      
      (source)
    </a>
    <a class="headerLink" href="#_raise_linalgerror_lstsq" title="numpy.linalg.linalg._raise_linalgerror_lstsq">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._raise_linalgerror_nonposdef">
    
  </a>
  <a name="_raise_linalgerror_nonposdef">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_raise_linalgerror_nonposdef</span>(err, flag):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L91">
      
      (source)
    </a>
    <a class="headerLink" href="#_raise_linalgerror_nonposdef" title="numpy.linalg.linalg._raise_linalgerror_nonposdef">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._raise_linalgerror_qr">
    
  </a>
  <a name="_raise_linalgerror_qr">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_raise_linalgerror_qr</span>(err, flag):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L103">
      
      (source)
    </a>
    <a class="headerLink" href="#_raise_linalgerror_qr" title="numpy.linalg.linalg._raise_linalgerror_qr">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._raise_linalgerror_singular">
    
  </a>
  <a name="_raise_linalgerror_singular">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_raise_linalgerror_singular</span>(err, flag):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L88">
      
      (source)
    </a>
    <a class="headerLink" href="#_raise_linalgerror_singular" title="numpy.linalg.linalg._raise_linalgerror_singular">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._raise_linalgerror_svd_nonconvergence">
    
  </a>
  <a name="_raise_linalgerror_svd_nonconvergence">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_raise_linalgerror_svd_nonconvergence</span>(err, flag):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L97">
      
      (source)
    </a>
    <a class="headerLink" href="#_raise_linalgerror_svd_nonconvergence" title="numpy.linalg.linalg._raise_linalgerror_svd_nonconvergence">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._realType">
    
  </a>
  <a name="_realType">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_realType</span>(t, default=double):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L130">
      
      (source)
    </a>
    <a class="headerLink" href="#_realType" title="numpy.linalg.linalg._realType">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._solve_dispatcher">
    
  </a>
  <a name="_solve_dispatcher">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_solve_dispatcher</span>(a, b):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L302">
      
      (source)
    </a>
    <a class="headerLink" href="#_solve_dispatcher" title="numpy.linalg.linalg._solve_dispatcher">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._svd_dispatcher">
    
  </a>
  <a name="_svd_dispatcher">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_svd_dispatcher</span>(a, full_matrices=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, compute_uv=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>, hermitian=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L1459">
      
      (source)
    </a>
    <a class="headerLink" href="#_svd_dispatcher" title="numpy.linalg.linalg._svd_dispatcher">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._tensorinv_dispatcher">
    
  </a>
  <a name="_tensorinv_dispatcher">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_tensorinv_dispatcher</span>(a, ind=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L391">
      
      (source)
    </a>
    <a class="headerLink" href="#_tensorinv_dispatcher" title="numpy.linalg.linalg._tensorinv_dispatcher">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._tensorsolve_dispatcher">
    
  </a>
  <a name="_tensorsolve_dispatcher">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_tensorsolve_dispatcher</span>(a, b, axes=<a href="https://docs.python.org/3/library/constants.html#None" class="intersphinx-link">None</a>):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L221">
      
      (source)
    </a>
    <a class="headerLink" href="#_tensorsolve_dispatcher" title="numpy.linalg.linalg._tensorsolve_dispatcher">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._to_native_byte_order">
    
  </a>
  <a name="_to_native_byte_order">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_to_native_byte_order</span>(*arrays):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L161">
      
      (source)
    </a>
    <a class="headerLink" href="#_to_native_byte_order" title="numpy.linalg.linalg._to_native_byte_order">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction private">
  
  
  <a name="numpy.linalg.linalg._unary_dispatcher">
    
  </a>
  <a name="_unary_dispatcher">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_unary_dispatcher</span>(a):
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L465">
      
      (source)
    </a>
    <a class="headerLink" href="#_unary_dispatcher" title="numpy.linalg.linalg._unary_dispatcher">
      
      
      ¶
    </a>
  </div>
  <div class="docstring functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basevariable private">
  
  
  <a name="numpy.linalg.linalg._complex_types_map">
    
  </a>
  <a name="_complex_types_map">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_complex_types_map</span> =
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L125">
      
      (source)
    </a>
    <a class="headerLink" href="#_complex_types_map" title="numpy.linalg.linalg._complex_types_map">
      
      
      ¶
    </a>
  </div>
  <div class="functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="basevariable private">
  
  
  <a name="numpy.linalg.linalg._linalg_error_extobj">
    
  </a>
  <a name="_linalg_error_extobj">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_linalg_error_extobj</span> =
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L85">
      
      (source)
    </a>
    <a class="headerLink" href="#_linalg_error_extobj" title="numpy.linalg.linalg._linalg_error_extobj">
      
      
      ¶
    </a>
  </div>
  <div class="functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div><div class="basevariable private">
  
  
  <a name="numpy.linalg.linalg._real_types_map">
    
  </a>
  <a name="_real_types_map">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_real_types_map</span> =
    <a class="sourceLink" href="https://github.com/pydocbrowser/pydocbrowser.github.io/tree/main/build/sources/numpy-1.24.0//numpy/linalg/linalg.py#L120">
      
      (source)
    </a>
    <a class="headerLink" href="#_real_types_map" title="numpy.linalg.linalg._real_types_map">
      
      
      ¶
    </a>
  </div>
  <div class="functionBody">
    
    <div><p class="undocumented">Undocumented</p></div>
    
  </div>
</div>
        </div>
      
      </div>
    </div>

    <footer class="navbar navbar-default">

  
  <div class="container">
    <a href="index.html">API Documentation</a> for numpy,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    22.9.1 at 2022-12-19 00:54:29.
  </div>

  <!-- Search related scripts needs to be loaded at the end of HTML 
    parsing not to introduce overhead and display HTML data asap -->
  <script src="ajax.js" type="text/javascript"></script>
  <script src="searchlib.js" type="text/javascript"></script>
  <script src="search.js" type="text/javascript"></script>

</footer>
  
    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>